[
  {
    "objectID": "scripts/ppi_network.html",
    "href": "scripts/ppi_network.html",
    "title": "Protein Protein Interaction (PPI) resources",
    "section": "",
    "text": "Code\nlibrary(stringr)\nlibrary(R.utils)\n\nlibrary(org.Hs.eg.db)\nlibrary(ensembldb)\nlibrary(EnsDb.Hsapiens.v86)\n\nlibrary(ggplot2)\nlibrary(ggrepel)\nlibrary(MetBrewer)\nlibrary(cowplot)\n\n\n\n\nLinks to each database:\n\nAPID Agile Protein Interactomes DataServer. Integration of known experimentally validated protein-protein physical interactions (PPIs).\nBIOGRID Biological General Repository for Interaction Datasets. Genetic and protein interaction data from model organisms and humans.\nBIOPLEX. Bioplex 3.0, comprehensive experimentally derived model of the human interactome.\nCORUM the COmprehensive ResoUrce of Mammalian protein complexes.\nHITPREDICT Physical protein-protein interactions with reliability scores.\nHURI The Human Reference Interactome.\nINTACT IntAct Molecular Interaction Database.\nMINT The Molecular INTeraction Database.\nREACTOME. Open-source, open access, manually curated and peer-reviewed pathway database\nSTRING. STRING is a Core Data Resource as designated by Global Biodata Coalition and ELIXIR.\n\n\n\nCode\ndir.create(path = \"./02_Datasets/\")\n\n\n\n\n\n\nAll datasets were mapped to Ensembl Gene ID from either Entrez, Uniprot or Ensembl Protein ID.\n\n\n\n\n\nCode\n# Annotations Entrez ID to Ensembl Gene ID\nx &lt;- org.Hs.egENSEMBL\n# Get the entrez gene IDs that are mapped to an Ensembl ID\nmapped_genes &lt;- mappedkeys(x)\n# Convert to a list\nxx &lt;- as.list(x[mapped_genes])\n\n# Built a Dataframe with unique Entrez IDs, possible multiple Ensembl Gene IDs delimited by \"||\"\nentrez_to_ensembl &lt;- matrix(NA, nrow = 1, ncol = 2)\nfor(i in 1:length(xx)){\n  if(length(unlist(xx[i])) == 1){\n    gci &lt;- cbind(names(xx[i]), unlist(xx[i]))\n  } else {\n    gci &lt;- cbind(names(xx[i]), paste0(unlist(xx[i]), collapse = \"||\"))\n  }\n  entrez_to_ensembl &lt;- rbind(entrez_to_ensembl, gci)\n  rm(gci)\n}\nrm(i, x, mapped_genes, xx)\nentrez_to_ensembl &lt;- entrez_to_ensembl[-1, ]\nrownames(entrez_to_ensembl) &lt;- 1:nrow(entrez_to_ensembl)\ncolnames(entrez_to_ensembl) &lt;- c(\"Entrez_ID\", \"Ensembl_GeneID\")\nentrez_to_ensembl &lt;- data.frame(entrez_to_ensembl)\n\n\n\n\n\n\n\nCode\n# Uniprot annotations from Ensembl\nedb &lt;- EnsDb.Hsapiens.v86\ntxs &lt;- genes(edb, columns = c(\"uniprot_id\"))\nuniprot_to_ensembl &lt;- mcols(txs)\ncolnames(uniprot_to_ensembl) &lt;- c(\"Uniprot_ID\", \"Ensembl_GeneID\")\n\n# Remove genes that do not match any Uniprot ID\nif(length(which(is.na(uniprot_to_ensembl$Uniprot_ID) == TRUE)) &gt; 0) {\n uniprot_to_ensembl &lt;- uniprot_to_ensembl[-which(is.na(uniprot_to_ensembl$Uniprot_ID) == TRUE), ] \n}\nrm(edb, txs)\n\nuniprot_to_ensembl &lt;- uniprot_to_ensembl[order(uniprot_to_ensembl$Uniprot_ID), ]\n\nuniprot_to_ensembl_unique &lt;- aggregate.data.frame(x = uniprot_to_ensembl,\n                                                  by = list(uniprot_to_ensembl$Uniprot_ID),\n                                                  FUN = function(x) paste0(x, collapse = \"||\"))\nrm(uniprot_to_ensembl)\nuniprot_to_ensembl &lt;- uniprot_to_ensembl_unique[, c(\"Group.1\", \"Ensembl_GeneID\")]\ncolnames(uniprot_to_ensembl) &lt;- c(\"Uniprot_ID\", \"Ensembl_GeneID\")\nrm(uniprot_to_ensembl_unique)\n\n\n\n\n\n\n\nCode\n# Uniprot annotations from Ensembl\nedb &lt;- EnsDb.Hsapiens.v86\ntxs &lt;- genes(edb, columns = c(\"protein_id\"))\nproteinID_to_ensembl &lt;- mcols(txs)\ncolnames(proteinID_to_ensembl) &lt;- c(\"protein_id\", \"Ensembl_GeneID\")\n\n# Remove genes that do not match any protein ID\nif(length(which(is.na(proteinID_to_ensembl$protein_id) == TRUE)) &gt; 0) {\n proteinID_to_ensembl &lt;- proteinID_to_ensembl[-which(is.na(proteinID_to_ensembl$protein_id) == TRUE), ] \n}\nrm(edb, txs)\n\nproteinID_to_ensembl &lt;- proteinID_to_ensembl[order(proteinID_to_ensembl$protein_id), ]\n\nproteinID_to_ensembl_unique &lt;- aggregate.data.frame(x = proteinID_to_ensembl,\n                                                  by = list(proteinID_to_ensembl$protein_id),\n                                                  FUN = function(x) paste0(x, collapse = \"||\"))\nrm(proteinID_to_ensembl)\nproteinID_to_ensembl &lt;- proteinID_to_ensembl_unique[, c(\"Group.1\", \"Ensembl_GeneID\")]\ncolnames(proteinID_to_ensembl) &lt;- c(\"Protein_ID\", \"Ensembl_GeneID\")\nrm(proteinID_to_ensembl_unique)\n\n\n\n\n\n\n\n\nCode\n# User friendly download through\n# http://cicblade.dep.usal.es:8080/APID/init.action\n# Organism Homo Sapiens\n# Level 0. all reported proteins pairs\n# filter out inter-species interactions select \"YES\"\n# File name 9606_noISI_Q3.txt\n\ndir.create(path = \"./02_Datasets/APID/\")\n\n\n\n\nCode\n# Apid #\ndb &lt;- read.delim(\"./02_Datasets/APID/9606_noISI_Q3.txt\", sep = \"\\t\", \n                 quote = NULL, header = TRUE, stringsAsFactors = FALSE)\n\n# Mapping through uniprot\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$UniprotID_A, table = uniprot_to_ensembl$Uniprot_ID)],\n                 Ensembl_Gene_Interactor_B = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$UniprotID_B, table = uniprot_to_ensembl$Uniprot_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Separate into interactions with a single and multiple Ensembl Gene IDs\ndb_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n\ndb_o2o &lt;- setdiff(x = 1:nrow(db), y = db_m2m)\ndb_m2m &lt;- db[db_m2m, ]\ndb_o2o &lt;- db[db_o2o, ]\n\n# Expand interactions with multiple ensembl gene IDs\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"ToRemove\", c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")))\nfor(i in c(1:nrow(db_m2m))){\n  in_a &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_A[i], pattern = \"\\\\|\\\\|\"))\n  in_b &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_B[i], pattern = \"\\\\|\\\\|\"))\n  ab &lt;- expand.grid(\"Ensembl_Gene_Interactor_A\" = in_a, \"Ensembl_Gene_Interactor_B\" = in_b)\n  output &lt;- rbind(output, ab)\n}\nrm(in_a, in_b, ab, i)\noutput &lt;- output[-1, ]\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- rbind(db_o2o[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")], \n                output)\nrm(db, db_m2m, db_o2o, output)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/APID/9606_noISI_Q3_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)\n\n\n\n\n\n\n\nCode\n# Download data from Biogrid by species\ndir.create(path = \"./02_Datasets/BIOGRID/\")\ndownload.file(url= \"https://downloads.thebiogrid.org/Download/BioGRID/Release-Archive/BIOGRID-4.4.230/BIOGRID-ORGANISM-4.4.230.tab3.zip\",\n              destfile = \"./02_Datasets/BIOGRID/BIOGRID-ORGANISM-4.4.230.tab3.zip\") \nunzip(zipfile = \"./02_Datasets/BIOGRID/BIOGRID-ORGANISM-4.4.230.tab3.zip\", \n      exdir = \"./02_Datasets/BIOGRID/BIOGRID-ORGANISM-4.4.230.tab3\")\nunlink(x = \"./02_Datasets/BIOGRID/BIOGRID-ORGANISM-4.4.230.tab3.zip/\", recursive = TRUE)\n\n# Keep only Homo sapiens \nfn &lt;- list.files(path = \"./02_Datasets/BIOGRID/BIOGRID-ORGANISM-4.4.230.tab3/\", full.names = TRUE)\nfn_hs &lt;- fn[str_detect(string = fn, pattern = \"Homo_sapiens\")]\nfn_rm &lt;- fn[str_detect(string = fn, pattern = \"Homo_sapiens\", negate = TRUE)]\nunlink(x = fn_rm)\nrm(fn, fn_rm)\n\n# BIOGRID files to system variables \nSys.setenv(BIOGRID_HS = fn_hs)\nSys.setenv(BIOGRID_HS_4R = paste0(fn_hs, \".4R\", sep = \"\"))\n\n\n\n\nCode\n\n# Parse file to remove ' and # from file\nsed \"s/'//g\" $BIOGRID_HS &gt; $BIOGRID_HS_4R\nsed \"s/#//g\" $BIOGRID_HS_4R &gt; $BIOGRID_HS\n\n\n\n\nCode\n# Remove intermediate file\nunlink(x = paste0(fn_hs, \".4R\", sep = \"\"))\n\n\n\n\nCode\n# Homo sapiens interactions from BIOGRID\ndb &lt;- read.table(file = fn_hs, sep = \"\\t\", \n                 header = TRUE, stringsAsFactors = FALSE)\nrm(fn_hs)\n\n# Keep only physical interactions between Homo sapiens  \ndb &lt;- db[which(db$Experimental.System.Type == \"physical\"), ]\ndb &lt;- db[which(db$Organism.Name.Interactor.A == \"Homo sapiens\"), ]\ndb &lt;- db[which(db$Organism.Name.Interactor.B == \"Homo sapiens\"), ]\n\n# Interactions from Entrez to Ensembl Gene IDs\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = entrez_to_ensembl$Ensembl_GeneID[match(x = db$Entrez.Gene.Interactor.A, table = entrez_to_ensembl$Entrez_ID)], \n                 Ensembl_Gene_Interactor_B = entrez_to_ensembl$Ensembl_GeneID[match(x = db$Entrez.Gene.Interactor.B, table = entrez_to_ensembl$Entrez_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Separate into interactions with a single and multiple Ensembl Gene IDs\ndb_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n\ndb_o2o &lt;- setdiff(x = 1:nrow(db), y = db_m2m)\ndb_m2m &lt;- db[db_m2m, ]\ndb_o2o &lt;- db[db_o2o, ]\n\n# Expand interactions with multiple ensembl gene IDs\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"ToRemove\", c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")))\nfor(i in c(1:nrow(db_m2m))){\n  in_a &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_A[i], pattern = \"\\\\|\\\\|\"))\n  in_b &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_B[i], pattern = \"\\\\|\\\\|\"))\n  ab &lt;- expand.grid(\"Ensembl_Gene_Interactor_A\" = in_a, \"Ensembl_Gene_Interactor_B\" = in_b)\n  output &lt;- rbind(output, ab)\n  \n}\nrm(in_a, in_b, ab, i)\noutput &lt;- output[-1, ]\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- rbind(db_o2o[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")], \n                output)\nrm(db, db_m2m, db_o2o, output)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/BIOGRID/BIOGRID-ORGANISM-4.4.230.tab3_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)\n\n\n\n\n\n\n\nCode\n# Data download\ndir.create(path = \"./02_Datasets/BIOPLEX/\")\n\n\n# Bioplex version 3.0 # \n# Same name different file size for HCT116\ndownload.file(url = \"https://bioplex.hms.harvard.edu/data/BioPlex_293T_Network_10K_Dec_2019.tsv\",\n                            destfile = \"./02_Datasets/BIOPLEX/BioPlex_293T_Network_10K_Dec_2019.tsv\")\ndownload.file(url = \"https://bioplex.hms.harvard.edu/data/BioPlex_HCT116_Network_5.5K_Dec_2019.tsv\",\n              destfile = \"./02_Datasets/BIOPLEX/BioPlex_HCT116_Network_5.5K_Dec_2019.tsv\")\n\n\n\n\n\n\nCode\n# Bioplex\ndb &lt;- read.table(file = \"./02_Datasets/BIOPLEX/BioPlex_293T_Network_10K_Dec_2019.tsv\", sep = \"\\t\", header = TRUE)\n\n# Remove isoform info to mapp Uniprot ID\ndb$UniprotA &lt;- sapply(str_split(string = db$UniprotA, pattern = \"-\"), \"[\", 1)\ndb$UniprotB &lt;- sapply(str_split(string = db$UniprotB, pattern = \"-\"), \"[\", 1)\n\n# Mapping through uniprot\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$UniprotA, table = uniprot_to_ensembl$Uniprot_ID)],\n                 Ensembl_Gene_Interactor_B = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$UniprotB, table = uniprot_to_ensembl$Uniprot_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Separate into interactions with a single and multiple Ensembl Gene IDs\ndb_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n\ndb_o2o &lt;- setdiff(x = 1:nrow(db), y = db_m2m)\ndb_m2m &lt;- db[db_m2m, ]\ndb_o2o &lt;- db[db_o2o, ]\n\n# Expand interactions with multiple ensembl gene IDs\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"ToRemove\", c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")))\nfor(i in c(1:nrow(db_m2m))){\n  in_a &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_A[i], pattern = \"\\\\|\\\\|\"))\n  in_b &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_B[i], pattern = \"\\\\|\\\\|\"))\n  ab &lt;- expand.grid(\"Ensembl_Gene_Interactor_A\" = in_a, \"Ensembl_Gene_Interactor_B\" = in_b)\n  output &lt;- rbind(output, ab)\n}\nrm(in_a, in_b, ab, i)\noutput &lt;- output[-1, ]\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- rbind(db_o2o[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")], \n                output)\nrm(db, db_m2m, db_o2o, output)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/BIOPLEX/BioPlex_293T_Network_10K_Dec_2019_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)\n\n\n\n\n\n\n\nCode\n# Bioplex\ndb &lt;- read.table(file = \"./02_Datasets/BIOPLEX/BioPlex_HCT116_Network_5.5K_Dec_2019.tsv\", sep = \"\\t\", header = TRUE)\n\n# Remove isoform info to mapp Uniprot ID\ndb$UniprotA &lt;- sapply(str_split(string = db$UniprotA, pattern = \"-\"), \"[\", 1)\ndb$UniprotB &lt;- sapply(str_split(string = db$UniprotB, pattern = \"-\"), \"[\", 1)\n\n# Mapping through uniprot\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$UniprotA, table = uniprot_to_ensembl$Uniprot_ID)],\n                 Ensembl_Gene_Interactor_B = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$UniprotB, table = uniprot_to_ensembl$Uniprot_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Separate into interactions with a single and multiple Ensembl Gene IDs\ndb_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n\ndb_o2o &lt;- setdiff(x = 1:nrow(db), y = db_m2m)\ndb_m2m &lt;- db[db_m2m, ]\ndb_o2o &lt;- db[db_o2o, ]\n\n# Expand interactions with multiple ensembl gene IDs\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"ToRemove\", c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")))\nfor(i in c(1:nrow(db_m2m))){\n  in_a &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_A[i], pattern = \"\\\\|\\\\|\"))\n  in_b &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_B[i], pattern = \"\\\\|\\\\|\"))\n  ab &lt;- expand.grid(\"Ensembl_Gene_Interactor_A\" = in_a, \"Ensembl_Gene_Interactor_B\" = in_b)\n  output &lt;- rbind(output, ab)\n}\nrm(in_a, in_b, ab, i)\noutput &lt;- output[-1, ]\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- rbind(db_o2o[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")], \n                output)\nrm(db, db_m2m, db_o2o, output)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/BIOPLEX/BioPlex_HCT116_Network_5.5K_Dec_2019_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)\n\n\n\n\n\n\n\n\nCode\ndir.create(\"./02_Datasets/CORUM/\")\n\n# Database is now (Feb 2024) online !\n\n# All complexes\ndownload.file(\"https://mips.helmholtz-muenchen.de/corum/download/releases/current/allComplexes.txt.zip\", \n              destfile = \"./02_Datasets/CORUM/allComplex.zip\")\n\n# Human complexes\ndownload.file(\"https://mips.helmholtz-muenchen.de/corum/download/releases/current/humanComplexes.txt.zip\", \n              destfile = \"./02_Datasets/CORUM/humanComplexes.txt.zip\")\n\n# Partial complexes\ndownload.file(\"https://mips.helmholtz-muenchen.de/corum/download/releases/current/partialComplexes.txt.zip\", \n              destfile = \"./02_Datasets/CORUM/partialComplexes.txt.zip\")\n\n# Unzip files\ngunzip(zipfile = \"./02_Datasets/CORUM/allComplexes.txt.zip\", remove = TRUE)\ngunzip(zipfile = \"./02_Datasets/CORUM/humanComplexes.txt.zip\", remove = TRUE)\ngunzip(zipfile = \"./02_Datasets/CORUM/partialComplexes.txt.zip\", remove = TRUE)\n\nSys.setenv(CORUM_ALL = \"./02_Datasets/CORUM/allComplexes.txt\")\nSys.setenv(CORUM_ALL_TMP = \"./02_Datasets/CORUM/allComplexes_tmp.txt\")\n\nSys.setenv(CORUM_HUM = \"./02_Datasets/CORUM/humanComplexes.txt\")\nSys.setenv(CORUM_HUM_TMP = \"./02_Datasets/CORUM/humanComplexes_tmp.txt\")\n\nSys.setenv(CORUM_PAR = \"./02_Datasets/CORUM/partialComplexes.txt\")\nSys.setenv(CORUM_PAR_TMP = \"./02_Datasets/CORUM/partialComplexes_tmp.txt\")\n\n\n\n\nCode\n\n# Parse file to remove ' from file\nsed \"s/'//g\" $CORUM_ALL &gt; $CORUM_ALL_TMP\nsed \"s/'//g\" $CORUM_HUM &gt; $CORUM_HUM_TMP\nsed \"s/'//g\" $CORUM_PAR &gt; $CORUM_PAR_TMP\n\n\n\n\nCode\n# Remove temporal file and rename\nunlink(x = \"./02_Datasets/CORUM/allComplexes.txt\")\nunlink(x = \"./02_Datasets/CORUM/humanComplexes.txt\")\nunlink(x = \"./02_Datasets/CORUM/partialComplexes.txt\")\n\nfile.rename(from = \"./02_Datasets/CORUM/allComplexes_tmp.txt\", to = \"./02_Datasets/CORUM/allComplexes.txt\")\nfile.rename(from = \"./02_Datasets/CORUM/humanComplexes_tmp.txt\", to = \"./02_Datasets/CORUM/humanComplexes.txt\")\nfile.rename(from = \"./02_Datasets/CORUM/partialComplexes_tmp.txt\", to = \"./02_Datasets/CORUM/partialComplexes.txt\")\n\n\n\n\n\n\nCode\n# CORUM\ndb &lt;- read.table(file = \"./02_Datasets/CORUM/allComplexes.txt\", sep = \"\\t\", header = TRUE)\n\n# Rename column names \ncolnames(db) &lt;- str_replace_all(string = colnames(db), pattern = \"\\\\.\", replacement = \"_\")\n\n# Reduce to human interactions\ndb &lt;- db[which(db$Organism == \"Human\"), ]\n\n# From complexes to pairs of interactions\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, \n                 dimnames = list(\"RemoveMe\", c(\"Interactor_A\", \"Interactor_B\")))\n\nfor(i in 1:nrow(db)){\n  ci &lt;- unlist(str_split(string = db$subunits_UniProt_IDs_[i], pattern = \";\"))\n  if(length(ci) &gt; 0){\n  output &lt;- rbind(output, expand.grid(\"Interactor_A\" = ci, \"Interactor_B\" = ci))  \n  }\n  rm(ci)\n}\nrm(i)\noutput &lt;- output[-1, ]\nrm(db)\ndb &lt;- output\nrm(output)\nrownames(db) &lt;- 1:nrow(db)\n\n# Add ensembl annotations\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Interactor_A, table = uniprot_to_ensembl$Uniprot_ID)],\n                 Ensembl_Gene_Interactor_B = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Interactor_B, table = uniprot_to_ensembl$Uniprot_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Separate into interactions with a single and multiple Ensembl Gene IDs\ndb_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n\ndb_o2o &lt;- setdiff(x = 1:nrow(db), y = db_m2m)\ndb_m2m &lt;- db[db_m2m, ]\ndb_o2o &lt;- db[db_o2o, ]\n\n# Expand interactions with multiple ensembl gene IDs\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"ToRemove\", c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")))\nfor(i in c(1:nrow(db_m2m))){\n  in_a &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_A[i], pattern = \"\\\\|\\\\|\"))\n  in_b &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_B[i], pattern = \"\\\\|\\\\|\"))\n  ab &lt;- expand.grid(\"Ensembl_Gene_Interactor_A\" = in_a, \"Ensembl_Gene_Interactor_B\" = in_b)\n  output &lt;- rbind(output, ab)\n}\nrm(in_a, in_b, ab, i)\noutput &lt;- output[-1, ]\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- rbind(db_o2o[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")], \n                output)\nrm(db, db_m2m, db_o2o, output)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/CORUM/allComplexes_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)\n\n\n\n\n\n\n\nCode\n# CORUM\ndb &lt;- read.table(file = \"./02_Datasets/CORUM/humanComplexes.txt\", sep = \"\\t\", header = TRUE)\n\n# Rename column names \ncolnames(db) &lt;- str_replace_all(string = colnames(db), pattern = \"\\\\.\", replacement = \"_\")\n\n# Reduce to human interactions\ndb &lt;- db[which(db$Organism == \"Human\"), ]\n\n# From complexes to pairs of interactions\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"RemoveMe\", c(\"Interactor_A\", \"Interactor_B\")))\nfor(i in 1:nrow(db)){\n  ci &lt;- unlist(str_split(string = db$subunits_UniProt_IDs_[i], pattern = \";\"))\n  if(length(ci) &gt; 0){\n  output &lt;- rbind(output, expand.grid(\"Interactor_A\" = ci, \"Interactor_B\" = ci))  \n  }\n  rm(ci)\n}\nrm(i)\noutput &lt;- output[-1, ]\nrm(db)\ndb &lt;- output\nrm(output)\nrownames(db) &lt;- 1:nrow(db)\n\n# Add ensembl annotations\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Interactor_A, table = uniprot_to_ensembl$Uniprot_ID)],\n                 Ensembl_Gene_Interactor_B = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Interactor_B, table = uniprot_to_ensembl$Uniprot_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Separate into interactions with a single and multiple Ensembl Gene IDs\ndb_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n\ndb_o2o &lt;- setdiff(x = 1:nrow(db), y = db_m2m)\ndb_m2m &lt;- db[db_m2m, ]\ndb_o2o &lt;- db[db_o2o, ]\n\n# Expand interactions with multiple ensembl gene IDs\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"ToRemove\", c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")))\nfor(i in c(1:nrow(db_m2m))){\n  in_a &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_A[i], pattern = \"\\\\|\\\\|\"))\n  in_b &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_B[i], pattern = \"\\\\|\\\\|\"))\n  ab &lt;- expand.grid(\"Ensembl_Gene_Interactor_A\" = in_a, \"Ensembl_Gene_Interactor_B\" = in_b)\n  output &lt;- rbind(output, ab)\n}\nrm(in_a, in_b, ab, i)\noutput &lt;- output[-1, ]\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- rbind(db_o2o[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")], \n                output)\nrm(db, db_m2m, db_o2o, output)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/CORUM/humanComplexes_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)\n\n\n\n\n\n\n\nCode\n# CORUM\ndb &lt;- read.table(file = \"./02_Datasets/CORUM/partialComplexes.txt\", sep = \"\\t\", header = TRUE)\n\n# Rename column names \ncolnames(db) &lt;- str_replace_all(string = colnames(db), pattern = \"\\\\.\", replacement = \"_\")\n\n# Reduce to human interactions\ndb &lt;- db[which(db$Organism == \"Human\"), ]\n\n# From complexes to pairs of interactions\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"RemoveMe\", c(\"Interactor_A\", \"Interactor_B\")))\nfor(i in 1:nrow(db)){\n  ci &lt;- unlist(str_split(string = db$subunits_UniProt_IDs_[i], pattern = \";\"))\n  if(length(ci) &gt; 0){\n  output &lt;- rbind(output, expand.grid(\"Interactor_A\" = ci, \"Interactor_B\" = ci))  \n  }\n  rm(ci)\n}\nrm(i)\noutput &lt;- output[-1, ]\nrm(db)\ndb &lt;- output\nrm(output)\nrownames(db) &lt;- 1:nrow(db)\n\n# Add ensembl annotations\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Interactor_A, table = uniprot_to_ensembl$Uniprot_ID)],\n                 Ensembl_Gene_Interactor_B = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Interactor_B, table = uniprot_to_ensembl$Uniprot_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Separate into interactions with a single and multiple Ensembl Gene IDs\ndb_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n\ndb_o2o &lt;- setdiff(x = 1:nrow(db), y = db_m2m)\ndb_m2m &lt;- db[db_m2m, ]\ndb_o2o &lt;- db[db_o2o, ]\n\n# Expand interactions with multiple ensembl gene IDs\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"ToRemove\", c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")))\nfor(i in c(1:nrow(db_m2m))){\n  in_a &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_A[i], pattern = \"\\\\|\\\\|\"))\n  in_b &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_B[i], pattern = \"\\\\|\\\\|\"))\n  ab &lt;- expand.grid(\"Ensembl_Gene_Interactor_A\" = in_a, \"Ensembl_Gene_Interactor_B\" = in_b)\n  output &lt;- rbind(output, ab)\n}\nrm(in_a, in_b, ab, i)\noutput &lt;- output[-1, ]\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- rbind(db_o2o[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")], \n                output)\nrm(db, db_m2m, db_o2o, output)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/CORUM/partialComplexes_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)\n\n\n\n\n\n\n\n\nCode\n\n# Download interactions - # August 2023 last update.\n# You require to write an email to ashwini@combinatics.com to request access \n# Just send name, affiliation and brief description of use to get access link.\n# tar zxvf ./02_Datasets/HITPREDICT/H_sapiens_interactions.txt.tgz\n# tar zxvf ./02_Datasets/HITPREDICT/HitPredict_interactions.txt.tgz\n\n\n\n\nCode\n# HitPredict latest\ndb &lt;- read.table(file = \"./02_Datasets/HITPREDICT/H_sapiens_interactions.txt\", sep = \"\\t\", header = TRUE, skip = 4)\n\n# Mapping through uniprot\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Uniprot1, table = uniprot_to_ensembl$Uniprot_ID)],\n                 Ensembl_Gene_Interactor_B = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Uniprot2, table = uniprot_to_ensembl$Uniprot_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Separate into interactions with a single and multiple Ensembl Gene IDs\ndb_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n\ndb_o2o &lt;- setdiff(x = 1:nrow(db), y = db_m2m)\ndb_m2m &lt;- db[db_m2m, ]\ndb_o2o &lt;- db[db_o2o, ]\n\n# Expand interactions with multiple ensembl gene IDs\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"ToRemove\", c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")))\nfor(i in c(1:nrow(db_m2m))){\n  in_a &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_A[i], pattern = \"\\\\|\\\\|\"))\n  in_b &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_B[i], pattern = \"\\\\|\\\\|\"))\n  ab &lt;- expand.grid(\"Ensembl_Gene_Interactor_A\" = in_a, \"Ensembl_Gene_Interactor_B\" = in_b)\n  output &lt;- rbind(output, ab)\n}\nrm(in_a, in_b, ab, i)\noutput &lt;- output[-1, ]\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- rbind(db_o2o[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")], \n                output)\nrm(db, db_m2m, db_o2o, output)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/HITPREDICT/H_sapiens_interactions_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)\n\n\n\n\n\n\n\nCode\ndir.create(path = \"./02_Datasets/HURI/\")\ndownload.file(url = \"http://www.interactome-atlas.org/data/HuRI.tsv\",\n              destfile = \"./02_Datasets/HURI/HuRI.tsv\")\n\ndownload.file(url = \"http://www.interactome-atlas.org/data/HI-union.tsv\", \n              destfile = \"./02_Datasets/HURI/HI-union.tsv\")\n\ndownload.file(url = \"http://www.interactome-atlas.org/data/Test_space_screens-19.tsv\", \n              destfile = \"./02_Datasets/HURI/Test_space_screens-19.tsv\")\n\ndownload.file(url = \"http://www.interactome-atlas.org/data/Lit-BM.tsv\", \n              destfile = \"./02_Datasets/HURI/Lit-BM.tsv\")\n\ndownload.file(url = \"http://www.interactome-atlas.org/data/Yang-16.tsv\", \n              destfile = \"./02_Datasets/HURI/Yang-16.tsv\")\n\ndownload.file(url = \"http://www.interactome-atlas.org/data/HI-II-14.tsv\", \n              destfile = \"./02_Datasets/HURI/HI-II-14.tsv\")\n\ndownload.file(url = \"http://www.interactome-atlas.org/data/Venkatesan-09.tsv\", \n              destfile = \"./02_Datasets/HURI/Venkatesan-09.tsv\")\n\ndownload.file(url = \"http://www.interactome-atlas.org/data/H-I-05.tsv\",\n              destfile = \"./02_Datasets/HURI/H-I-05.tsv\")\n\ndownload.file(url = \"http://www.interactome-atlas.org/data/Yu-11.tsv\",\n              destfile = \"./02_Datasets/HURI/Yu-11.tsv\")\n\nfn &lt;- list.files(path = \"./02_Datasets/HURI/\", full.names = TRUE)\n\n\n\n\nCode\nfor (i in c(1:length(fn))){\n  \n  # HuRI\n  db_ens &lt;- read.table(file = fn[i], sep = \"\\t\", header = FALSE)\n\n  # Remove self interactions\n  mark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\n  if(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\n  rm(mark_self)\n\n  # Re-order interactions to remove duplicates\n  db_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\n  db_ens &lt;- unique(db_ens_order) \n  rm(db_ens_order)\n\n  out_name &lt;- paste0(str_replace(string = fn[i], \n                                 pattern = \".tsv\", \n                                 replacement = \"\"), \n                     \"_EnsemblGeneID.txt\", collapse = \"\")\n\n  # Save as tab delimited file \n  write.table(x = db_ens, \n              file = out_name, \n              sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)\n  rm(db_ens, out_name)\n}\nrm(fn, i)\n\n\n\n\n\n\n\nCode\n# Data download\ndir.create(path = \"./02_Datasets/INTACT/\")\ndownload.file(url = \"https://ftp.ebi.ac.uk/pub/databases/intact/current/psimitab/intact.zip\",\n              destfile = \"./02_Datasets/INTACT/intact.zip\") \nunzip(zipfile = \"./02_Datasets/INTACT/intact.zip\", exdir = \"./02_Datasets/INTACT/\")\nunlink(x = \"./02_Datasets/INTACT/intact.zip\")\n\n# INTACT files to system variables \nSys.setenv(INTACT = \"./02_Datasets/INTACT/intact.txt\")\nSys.setenv(INTACT_TMP = \"./02_Datasets/INTACT/intact_tmp.txt\")\n\n\n\n\nCode\n\n# Parse file to remove ' and # from file\nsed \"s/'//g\" $INTACT &gt; $INTACT_TMP\nsed \"s/#//g\" $INTACT_TMP &gt; $INTACT\n\n\n\n\nCode\n# Remove intermediate files\nunlink(x = \"./02_Datasets/INTACT/intact_tmp.txt\")\n\n\n\n\nCode\n# Intact db\ndb &lt;- read.table(file = \"./02_Datasets/INTACT/intact.txt\", sep = \"\\t\", quote = \"\", header = TRUE)\n\n# Replace \".\" from colnames \ncolnames(db) &lt;- str_replace_all(string = colnames(db), pattern = \"\\\\.\\\\.\", replacement = \".\")\ncolnames(db) &lt;- str_replace_all(string = colnames(db), pattern = \"\\\\.\", replacement = \"_\")\n\n# Only within human interactions\nhsap &lt;- intersect(which(str_detect(string = db$Taxid_interactor_A, pattern = \"taxid:9606\") == TRUE), \n                  which(str_detect(string = db$Taxid_interactor_B, pattern = \"taxid:9606\") == TRUE))\ndb &lt;- db[hsap, ]\nrm(hsap)\n\n# Mapping through uniprot\nuni &lt;- intersect(which(str_detect(string = db$ID_s_interactor_A, pattern = \"uniprotkb\") == TRUE),\n                 which(str_detect(string = db$ID_s_interactor_B, pattern = \"uniprotkb\") == TRUE))\ndb &lt;- db[uni, ]\nrm(uni)\ndb$ID_s_interactor_A &lt;- str_replace(string = db$ID_s_interactor_A, pattern = \"uniprotkb:\", replacement = \"\")\ndb$ID_s_interactor_B &lt;- str_replace(string = db$ID_s_interactor_B, pattern = \"uniprotkb:\", replacement = \"\")\n\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$ID_s_interactor_A, table = uniprot_to_ensembl$Uniprot_ID)],\n                 Ensembl_Gene_Interactor_B = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$ID_s_interactor_B, table = uniprot_to_ensembl$Uniprot_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Separate into interactions with a single and multiple Ensembl Gene IDs\ndb_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n\ndb_o2o &lt;- setdiff(x = 1:nrow(db), y = db_m2m)\ndb_m2m &lt;- db[db_m2m, ]\ndb_o2o &lt;- db[db_o2o, ]\n\n# Expand interactions with multiple ensembl gene IDs\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"ToRemove\", c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")))\nfor(i in c(1:nrow(db_m2m))){\n  in_a &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_A[i], pattern = \"\\\\|\\\\|\"))\n  in_b &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_B[i], pattern = \"\\\\|\\\\|\"))\n  ab &lt;- expand.grid(\"Ensembl_Gene_Interactor_A\" = in_a, \"Ensembl_Gene_Interactor_B\" = in_b)\n  output &lt;- rbind(output, ab)\n}\nrm(in_a, in_b, ab, i)\noutput &lt;- output[-1, ]\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- rbind(db_o2o[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")], \n                output)\nrm(db, db_m2m, db_o2o, output)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/INTACT/intact_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)\n\n\n\n\n\n\n\nCode\n# Data download\ndir.create(path = \"./02_Datasets/MINT/\")\n\ndownload.file(url = \"http://www.ebi.ac.uk/Tools/webservices/psicquic/mint/webservices/current/search/query/species:human\",\n              destfile = \"./02_Datasets/MINT/species_human.txt\")\n\nSys.setenv(MINT = \"./02_Datasets/MINT/species_human.txt\")\nSys.setenv(MINT_4R = \"./02_Datasets/MINT/species_human_tmp.txt\")\n\n\n\n\nCode\n\n# Parse file to remove ' and # from file\nsed \"s/'//g\" $MINT &gt; $MINT_4R\nsed \"s/#//g\" $MINT_4R &gt; $MINT\n\n\n\n\nCode\n# Remove temporal file\nunlink(x = \"./02_Datasets/MINT/species_human_tmp.txt\")\n\n\n\n\nCode\n# Mint\ndb &lt;- read.delim(\"./02_Datasets/MINT/species_human.txt\", sep = \"\\t\", quote = NULL, header = FALSE, stringsAsFactors = FALSE)\n\n# Rename a few columns\ncolnames(db)[1:2] &lt;- c(\"Interactor_A\", \"Interactor_B\")\ncolnames(db)[10:11] &lt;- c(\"Taxid_interactor_A\", \"Taxid_interactor_B\")\n\n# Only within human interactions\nhsap &lt;- intersect(which(str_detect(string = db$Taxid_interactor_A, pattern = \"taxid:9606\") == TRUE), \n                  which(str_detect(string = db$Taxid_interactor_B, pattern = \"taxid:9606\") == TRUE))\ndb &lt;- db[hsap, ]\nrm(hsap)\n\n# Mapping through uniprot\nuni &lt;- intersect(which(str_detect(string = db$Interactor_A, pattern = \"uniprotkb\") == TRUE),\n                 which(str_detect(string = db$Interactor_B, pattern = \"uniprotkb\") == TRUE))\ndb &lt;- db[uni, ]\nrm(uni)\ndb$Interactor_A &lt;- str_replace(string = db$Interactor_A, pattern = \"uniprotkb:\", replacement = \"\")\ndb$Interactor_B &lt;- str_replace(string = db$Interactor_B, pattern = \"uniprotkb:\", replacement = \"\")\n\n# Mapping through uniprot\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Interactor_A, table = uniprot_to_ensembl$Uniprot_ID)],\n                 Ensembl_Gene_Interactor_B = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Interactor_B, table = uniprot_to_ensembl$Uniprot_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Separate into interactions with a single and multiple Ensembl Gene IDs\ndb_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n\ndb_o2o &lt;- setdiff(x = 1:nrow(db), y = db_m2m)\ndb_m2m &lt;- db[db_m2m, ]\ndb_o2o &lt;- db[db_o2o, ]\n\n# Expand interactions with multiple ensembl gene IDs\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"ToRemove\", c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")))\nfor(i in c(1:nrow(db_m2m))){\n  in_a &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_A[i], pattern = \"\\\\|\\\\|\"))\n  in_b &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_B[i], pattern = \"\\\\|\\\\|\"))\n  ab &lt;- expand.grid(\"Ensembl_Gene_Interactor_A\" = in_a, \"Ensembl_Gene_Interactor_B\" = in_b)\n  output &lt;- rbind(output, ab)\n}\nrm(in_a, in_b, ab, i)\noutput &lt;- output[-1, ]\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- rbind(db_o2o[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")], \n                output)\nrm(db, db_m2m, db_o2o, output)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/MINT/species_human_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)\n\n\n\n\n\n\n\nCode\n# Data download\ndir.create(path = \"./02_Datasets/REACTOME/\")\ndownload.file(url = \"https://reactome.org/download/current/interactors/reactome.homo_sapiens.interactions.tab-delimited.txt\",\n              destfile = \"./02_Datasets/REACTOME/reactome.homo_sapiens.interactions.tab-delimited.txt\") \n\n\n# REACTOME files to system variables \nSys.setenv(REACTOME = \"./02_Datasets/REACTOME/reactome.homo_sapiens.interactions.tab-delimited.txt\")\nSys.setenv(REACTOME_TMP = \"./02_Datasets/REACTOME/reactome.homo_sapiens.interactions.tab-delimited_tmp.txt\")\n\n\n\n\nCode\n\n# Parse file to remove ' and # from file\nsed \"s/'//g\" $REACTOME &gt; $REACTOME_TMP\nsed \"s/#//g\" $REACTOME_TMP &gt; $REACTOME\n\n\n\n\nCode\n# Remove intermediate files\nunlink(x = \"./02_Datasets/REACTOME/reactome.homo_sapiens.interactions.tab-delimited_tmp.txt\")\n\n\n\n\nCode\n# Reactome\ndb &lt;- read.table(file = \"./02_Datasets/REACTOME/reactome.homo_sapiens.interactions.tab-delimited.txt\", sep = \"\\t\", quote = \"\", header = TRUE)\n\n# Replace \".\" from colnames \ncolnames(db) &lt;- str_replace_all(string = colnames(db), pattern = \"\\\\.\", replacement = \"_\")\n\n# Mapping through uniprot\nuni &lt;- intersect(which(str_detect(string = db$Interactor_1_uniprot_id, pattern = \"uniprotkb\") == TRUE),\n                 which(str_detect(string = db$Interactor_2_uniprot_id, pattern = \"uniprotkb\") == TRUE))\ndb &lt;- db[uni, ]\nrm(uni)\ndb$Interactor_1_uniprot_id &lt;- str_replace(string = db$Interactor_1_uniprot_id, pattern = \"uniprotkb:\", replacement = \"\")\ndb$Interactor_2_uniprot_id &lt;- str_replace(string = db$Interactor_2_uniprot_id, pattern = \"uniprotkb:\", replacement = \"\")\n\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Interactor_1_uniprot_id, table = uniprot_to_ensembl$Uniprot_ID)],\n                 Ensembl_Gene_Interactor_B = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Interactor_2_uniprot_id, table = uniprot_to_ensembl$Uniprot_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Separate into interactions with a single and multiple Ensembl Gene IDs\ndb_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n\ndb_o2o &lt;- setdiff(x = 1:nrow(db), y = db_m2m)\ndb_m2m &lt;- db[db_m2m, ]\ndb_o2o &lt;- db[db_o2o, ]\n\n# Expand interactions with multiple ensembl gene IDs\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"ToRemove\", c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")))\nfor(i in c(1:nrow(db_m2m))){\n  in_a &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_A[i], pattern = \"\\\\|\\\\|\"))\n  in_b &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_B[i], pattern = \"\\\\|\\\\|\"))\n  ab &lt;- expand.grid(\"Ensembl_Gene_Interactor_A\" = in_a, \"Ensembl_Gene_Interactor_B\" = in_b)\n  output &lt;- rbind(output, ab)\n}\nrm(in_a, in_b, ab, i)\noutput &lt;- output[-1, ]\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- rbind(db_o2o[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")], \n                output)\nrm(db, db_m2m, db_o2o, output)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/REACTOME/reactome.homo_sapiens.interactions.tab-delimited_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)\n\n\n\n\n\n\n\nCode\n# Data download\ndir.create(path = \"./02_Datasets/STRING/\")\n\ndownload.file(url = \"https://stringdb-downloads.org/download/protein.links.v12.0/9606.protein.links.v12.0.txt.gz\",\n              destfile = \"./02_Datasets/STRING/9606.protein.links.v12.0.txt.gz\")\n\ndownload.file(url = \"https://stringdb-downloads.org/download/protein.physical.links.v12.0/9606.protein.physical.links.v12.0.txt.gz\",\n              destfile = \"./02_Datasets/STRING/9606.protein.physical.links.v12.0.txt.gz\")\n\ngunzip(\"./02_Datasets/STRING/9606.protein.links.v12.0.txt.gz\", remove = TRUE)\ngunzip(\"./02_Datasets/STRING/9606.protein.physical.links.v12.0.txt.gz\", remove = TRUE)\n\n\n\n\n\n\nCode\n# String\ndb &lt;- read.table(file = \"./02_Datasets/STRING/9606.protein.links.v12.0.txt\", header = TRUE)\ndb$protein1 &lt;- str_replace(string = db$protein1, pattern = \"9606.\", replacement = \"\")\ndb$protein2 &lt;- str_replace(string = db$protein2, pattern = \"9606.\", replacement = \"\")\n\n# Mapping through protein ID\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = proteinID_to_ensembl$Ensembl_GeneID[match(x = db$protein1, table = proteinID_to_ensembl$Protein_ID)],\n                 Ensembl_Gene_Interactor_B = proteinID_to_ensembl$Ensembl_GeneID[match(x = db$protein2, table = proteinID_to_ensembl$Protein_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Check if there are multiple Ensembl Gene IDs\n#db_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n#                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n#length(db_m2m)\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- db[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")]\nrm(db)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/STRING/9606.protein.links.v12.0_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)\n\n\n\n\n\n\n\nCode\n# String\ndb &lt;- read.table(file = \"./02_Datasets/STRING/9606.protein.physical.links.v12.0.txt\", header = TRUE)\ndb$protein1 &lt;- str_replace(string = db$protein1, pattern = \"9606.\", replacement = \"\")\ndb$protein2 &lt;- str_replace(string = db$protein2, pattern = \"9606.\", replacement = \"\")\n\n# Mapping through protein ID\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = proteinID_to_ensembl$Ensembl_GeneID[match(x = db$protein1, table = proteinID_to_ensembl$Protein_ID)],\n                 Ensembl_Gene_Interactor_B = proteinID_to_ensembl$Ensembl_GeneID[match(x = db$protein2, table = proteinID_to_ensembl$Protein_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Check if there are multiple Ensembl Gene IDs\n#db_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n#                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n#length(db_m2m)\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- db[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")]\nrm(db)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/STRING/9606.protein.physical.links.v12.0_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)\n\n\n\n\n\n\n\n\nCode\n# List all protein protein interactions given in Ensembl Gene IDs\nfn &lt;- list.files(path = \"./02_Datasets/\", recursive = TRUE, pattern = \"EnsemblGeneID\", full.names = TRUE)\n\ngfn &lt;- sapply(str_split(string = fn, pattern = \"\\\\/\"), \"[\", 3)\ngfd &lt;- str_replace(string = sapply(str_split(string = fn, pattern = \"\\\\/\"), \"[\", 4), \n                   pattern = \"_EnsemblGeneID.txt\", replacement = \"\")\n\n# Relabel datasets # \nnames_datasets &lt;- data.frame(fn_sub = c(\"9606_noISI_Q3\", \n                                        \"BIOGRID-ORGANISM-Homo_sapiens-4.4.230.tab3\",\n                                        \"BioPlex_293T_Network_10K_Dec_2019\", \"BioPlex_HCT116_Network_5.5K_Dec_2019\",\n                                        \"allComplexes\", \"humanComplexes\", \"partialComplexes\", \n                                        \"H_sapiens_interactions\",\n                                        \"H-I-05\", \"HI-II-14\", \"HI-union\", \"HuRI\", \"Lit-BM\", \n                                        \"Test_space_screens-19\", \"Venkatesan-09\", \"Yang-16\", \"Yu-11\",\n                                        \"intact\", \n                                        \"species_human\",\n                                        \"reactome.homo_sapiens.interactions.tab-delimited\",\n                                        \"9606.protein.links.v12.0\", \"9606.protein.physical.links.v12.0\"),\n                             Dataset = c(\"APID\", \n                                         \"BIOGRID\", \n                                         \"BIOPLEX_293T\", \"BIOPLEX_HCT116\",\n                                         \"CORUM_All\", \"CORUM_human\", \"CORUM_partial\",  \n                                         \"HITPREDICT_latest\",\n                                         \"HURI_H-I-05\", \"HURI_HI-II-14\", \"HURI_HI-union\", \"HURI_HuRI\", \"HURI_Lit-BM\",\n                                         \"HURI_Test19\", \"HURI_Venkatesan\", \"HURI_Yang\", \"HURI_Yu\",\n                                         \"INTACT\", \n                                         \"MINT\", \n                                         \"REACTOME\",\n                                         \"STRING_Links\", \"STRING_Physical\"))\n\n# Obtain an overview of each\noutput &lt;- matrix(NA, length(fn), 4, \n                 dimnames = list(gfd, c(\"Genes\", \"Interactions\", \"Mean per gene\", \"Median per gene\")))\n\nfor (i in c(1:length(fn))){ \n  fni &lt;- read.table(file = fn[i], sep = \"\\t\", stringsAsFactors = FALSE)\n  output[i, 1] &lt;- length(unique(c(fni$V1, fni$V2)))\n  output[i, 2] &lt;- nrow(fni)\n  output[i, 3] &lt;- mean(table(c(fni$V1, fni$V2)))\n  output[i, 4] &lt;- median(table(c(fni$V1, fni$V2)))\n}\nrm(fni, i)\n\noutput &lt;- data.frame(Source = gfn, fn_sub = gfd, output)\noutput &lt;- merge(output, names_datasets, by = \"fn_sub\")\n\n\n\n\nCode\n# Number of genes\ng1 &lt;- ggplot(data = output, mapping = aes(x = Dataset, y = Genes, fill = Source, label = Genes)) + \n  geom_col() + geom_text(angle = 90, size = 3) + theme_classic() +\n  theme(legend.position = \"none\", \n        axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0))\n\n# Number of interactions\ng2 &lt;- ggplot(data = output, mapping = aes(x = Dataset, y = Interactions, \n                                          fill = Source, label = Interactions)) + \n  geom_col() + geom_text(angle = 90, size = 3) + theme_classic() +\n  theme(legend.position = \"none\", \n        axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0))\n\n# Mean interactions per gene\ng3 &lt;- ggplot(data = output, mapping = aes(x = Dataset, y = Mean.per.gene, \n                                          fill = Source)) + \n  geom_col() + theme_classic() +\n  theme(legend.position = \"none\", \n        axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0))\n\n# Median interactions per gene\ng4 &lt;- ggplot(data = output, mapping = aes(x = Dataset, y = Median.per.gene, \n                                          fill = Source)) + \n  geom_col() + theme_classic() +\n  theme(legend.position = \"none\", \n        axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0))\n\n# Overview\ng5 &lt;- ggplot(data = output, mapping = aes(x = log10(Interactions), \n                                          y = Genes, \n                                          color = Source, \n                                          size = Median.per.gene,\n                                          label = Dataset)) + \n  geom_point() + \n  geom_text_repel() + \n  theme_classic() + \n  scale_color_met_d(name = \"Signac\")\n\ng1\ng2\ng3\ng4\ng5\n\nrm(g1, g2, g3, g4, g5, output)\n\n\n\n\n\n\n\nCode\n# Create directory for merged PPI\ndir.create(path = \"./03_PPIMerged/\")\n\n\n\n\n\n\nCode\n# Combine all datasets\nPPIall &lt;- read.table(fn[1], header = FALSE)\n\nfor(i in c(2:length(fn))){\n  ppi &lt;- read.table(file = fn[i], header = FALSE)\n  PPIall &lt;- rbind(PPIall, ppi)\n  rm(ppi)\n}\n\n# Keep only unique interactions\nPPIall &lt;- unique(PPIall)\n\nfn_ppi &lt;- paste0(c(\"./03_PPIMerged/\",\n                   \"MergedPPI_\",\n                   paste0(sapply(str_split(date(), \" \"), \"[\", c(5, 2)), collapse = \"\"),\n                   # unique(gfn), # Optional to include names of datasets in output file\n                   \".txt\"),\n                 collapse = \"\")\n\nwrite.table(x = PPIall, file = fn_ppi, sep = \"\\t\", \n            quote = FALSE, row.names = FALSE, col.names = FALSE)\n\nrm(PPIall)\n\n\n\n\nCode\n# Combine datasets except string links\nfn &lt;- setdiff(fn, y = \"./02_Datasets/STRING/9606.protein.links.v12.0_EnsemblGeneID.txt\")\n\nPPIall &lt;- read.table(fn[1], header = FALSE)\n\nfor(i in c(2:length(fn))){\n  ppi &lt;- read.table(file = fn[i], header = FALSE)\n  PPIall &lt;- rbind(PPIall, ppi)\n  rm(ppi)\n}\n\n# Keep only unique interactions\nPPIall &lt;- unique(PPIall)\n\nfn_ppi &lt;- paste0(c(\"./03_PPIMerged/\",\n                   \"MergedPPI_\",\n                   paste0(sapply(str_split(date(), \" \"), \"[\", c(5, 2)), collapse = \"\"),\n                   # unique(gfn), # Optional to include names of datasets in output file\n                   \"_PIO_STRING.txt\"),\n                 collapse = \"\")\n\nwrite.table(x = PPIall, file = fn_ppi, sep = \"\\t\", \n            quote = FALSE, row.names = FALSE, col.names = FALSE)\n\n\n\n\n\n\n\nAPID Alonso-Lopez, D., et al. (2019). “APID database: redefining protein-protein interaction experimental evidences and binary interactomes.” Database (Oxford) 2019.\nAPID Alonso-Lopez, D., et al. (2016). “APID interactomes: providing proteome-based interactomes with controlled quality for multiple species and derived networks.” Nucleic Acids Res 44(W1): W529-535.\nBIOGRID Oughtred, R., et al. (2021). “The BioGRID database: A comprehensive biomedical resource of curated protein, genetic, and chemical interactions.” Protein Sci 30(1): 187-200.\nBIOPLEX Huttlin, E. L., et al. (2021). “Dual proteome-scale networks reveal cell-specific remodeling of the human interactome.” Cell 184(11): 3022-3040 e3028.\nCORUM Tsitsiridis, G., et al. (2023). “CORUM: the comprehensive resource of mammalian protein complexes-2022.” Nucleic Acids Res 51(D1): D539-D545.\nCORUM Giurgiu, M., et al. (2019). “CORUM: the comprehensive resource of mammalian protein complexes-2019.” Nucleic Acids Res 47(D1): D559-D563.\nHITPREDICT Lopez, Y., et al. (2015). “HitPredict version 4: comprehensive reliability scoring of physical protein-protein interactions from more than 100 species.” Database (Oxford) 2015.\nHURI Luck, K., et al. (2020). “A reference map of the human binary protein interactome.” Nature 580(7803): 402-408.\nINTACT Orchard, S., et al. (2014). “The MIntAct project–IntAct as a common curation platform for 11 molecular interaction databases.” Nucleic Acids Res 42(Database issue): D358-363.\nMINT Licata, L., et al. (2012). “MINT, the molecular interaction database: 2012 update.” Nucleic Acids Res 40(Database issue): D857-861.\nREACTOME Gillespie, M., et al. (2022). “The reactome pathway knowledgebase 2022.” Nucleic Acids Res 50(D1): D687-D692.\nSTRING Szklarczyk, D., et al. (2023). “The STRING database in 2023: protein-protein association networks and functional enrichment analyses for any sequenced genome of interest.” Nucleic Acids Res 51(D1): D638-D646."
  },
  {
    "objectID": "scripts/ppi_network.html#sources",
    "href": "scripts/ppi_network.html#sources",
    "title": "Protein Protein Interaction (PPI) resources",
    "section": "",
    "text": "Links to each database:\n\nAPID Agile Protein Interactomes DataServer. Integration of known experimentally validated protein-protein physical interactions (PPIs).\nBIOGRID Biological General Repository for Interaction Datasets. Genetic and protein interaction data from model organisms and humans.\nBIOPLEX. Bioplex 3.0, comprehensive experimentally derived model of the human interactome.\nCORUM the COmprehensive ResoUrce of Mammalian protein complexes.\nHITPREDICT Physical protein-protein interactions with reliability scores.\nHURI The Human Reference Interactome.\nINTACT IntAct Molecular Interaction Database.\nMINT The Molecular INTeraction Database.\nREACTOME. Open-source, open access, manually curated and peer-reviewed pathway database\nSTRING. STRING is a Core Data Resource as designated by Global Biodata Coalition and ELIXIR.\n\n\n\nCode\ndir.create(path = \"./02_Datasets/\")"
  },
  {
    "objectID": "scripts/ppi_network.html#id-mapping",
    "href": "scripts/ppi_network.html#id-mapping",
    "title": "Protein Protein Interaction (PPI) resources",
    "section": "",
    "text": "All datasets were mapped to Ensembl Gene ID from either Entrez, Uniprot or Ensembl Protein ID.\n\n\n\n\n\nCode\n# Annotations Entrez ID to Ensembl Gene ID\nx &lt;- org.Hs.egENSEMBL\n# Get the entrez gene IDs that are mapped to an Ensembl ID\nmapped_genes &lt;- mappedkeys(x)\n# Convert to a list\nxx &lt;- as.list(x[mapped_genes])\n\n# Built a Dataframe with unique Entrez IDs, possible multiple Ensembl Gene IDs delimited by \"||\"\nentrez_to_ensembl &lt;- matrix(NA, nrow = 1, ncol = 2)\nfor(i in 1:length(xx)){\n  if(length(unlist(xx[i])) == 1){\n    gci &lt;- cbind(names(xx[i]), unlist(xx[i]))\n  } else {\n    gci &lt;- cbind(names(xx[i]), paste0(unlist(xx[i]), collapse = \"||\"))\n  }\n  entrez_to_ensembl &lt;- rbind(entrez_to_ensembl, gci)\n  rm(gci)\n}\nrm(i, x, mapped_genes, xx)\nentrez_to_ensembl &lt;- entrez_to_ensembl[-1, ]\nrownames(entrez_to_ensembl) &lt;- 1:nrow(entrez_to_ensembl)\ncolnames(entrez_to_ensembl) &lt;- c(\"Entrez_ID\", \"Ensembl_GeneID\")\nentrez_to_ensembl &lt;- data.frame(entrez_to_ensembl)\n\n\n\n\n\n\n\nCode\n# Uniprot annotations from Ensembl\nedb &lt;- EnsDb.Hsapiens.v86\ntxs &lt;- genes(edb, columns = c(\"uniprot_id\"))\nuniprot_to_ensembl &lt;- mcols(txs)\ncolnames(uniprot_to_ensembl) &lt;- c(\"Uniprot_ID\", \"Ensembl_GeneID\")\n\n# Remove genes that do not match any Uniprot ID\nif(length(which(is.na(uniprot_to_ensembl$Uniprot_ID) == TRUE)) &gt; 0) {\n uniprot_to_ensembl &lt;- uniprot_to_ensembl[-which(is.na(uniprot_to_ensembl$Uniprot_ID) == TRUE), ] \n}\nrm(edb, txs)\n\nuniprot_to_ensembl &lt;- uniprot_to_ensembl[order(uniprot_to_ensembl$Uniprot_ID), ]\n\nuniprot_to_ensembl_unique &lt;- aggregate.data.frame(x = uniprot_to_ensembl,\n                                                  by = list(uniprot_to_ensembl$Uniprot_ID),\n                                                  FUN = function(x) paste0(x, collapse = \"||\"))\nrm(uniprot_to_ensembl)\nuniprot_to_ensembl &lt;- uniprot_to_ensembl_unique[, c(\"Group.1\", \"Ensembl_GeneID\")]\ncolnames(uniprot_to_ensembl) &lt;- c(\"Uniprot_ID\", \"Ensembl_GeneID\")\nrm(uniprot_to_ensembl_unique)\n\n\n\n\n\n\n\nCode\n# Uniprot annotations from Ensembl\nedb &lt;- EnsDb.Hsapiens.v86\ntxs &lt;- genes(edb, columns = c(\"protein_id\"))\nproteinID_to_ensembl &lt;- mcols(txs)\ncolnames(proteinID_to_ensembl) &lt;- c(\"protein_id\", \"Ensembl_GeneID\")\n\n# Remove genes that do not match any protein ID\nif(length(which(is.na(proteinID_to_ensembl$protein_id) == TRUE)) &gt; 0) {\n proteinID_to_ensembl &lt;- proteinID_to_ensembl[-which(is.na(proteinID_to_ensembl$protein_id) == TRUE), ] \n}\nrm(edb, txs)\n\nproteinID_to_ensembl &lt;- proteinID_to_ensembl[order(proteinID_to_ensembl$protein_id), ]\n\nproteinID_to_ensembl_unique &lt;- aggregate.data.frame(x = proteinID_to_ensembl,\n                                                  by = list(proteinID_to_ensembl$protein_id),\n                                                  FUN = function(x) paste0(x, collapse = \"||\"))\nrm(proteinID_to_ensembl)\nproteinID_to_ensembl &lt;- proteinID_to_ensembl_unique[, c(\"Group.1\", \"Ensembl_GeneID\")]\ncolnames(proteinID_to_ensembl) &lt;- c(\"Protein_ID\", \"Ensembl_GeneID\")\nrm(proteinID_to_ensembl_unique)"
  },
  {
    "objectID": "scripts/ppi_network.html#apid",
    "href": "scripts/ppi_network.html#apid",
    "title": "Protein Protein Interaction (PPI) resources",
    "section": "",
    "text": "Code\n# User friendly download through\n# http://cicblade.dep.usal.es:8080/APID/init.action\n# Organism Homo Sapiens\n# Level 0. all reported proteins pairs\n# filter out inter-species interactions select \"YES\"\n# File name 9606_noISI_Q3.txt\n\ndir.create(path = \"./02_Datasets/APID/\")\n\n\n\n\nCode\n# Apid #\ndb &lt;- read.delim(\"./02_Datasets/APID/9606_noISI_Q3.txt\", sep = \"\\t\", \n                 quote = NULL, header = TRUE, stringsAsFactors = FALSE)\n\n# Mapping through uniprot\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$UniprotID_A, table = uniprot_to_ensembl$Uniprot_ID)],\n                 Ensembl_Gene_Interactor_B = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$UniprotID_B, table = uniprot_to_ensembl$Uniprot_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Separate into interactions with a single and multiple Ensembl Gene IDs\ndb_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n\ndb_o2o &lt;- setdiff(x = 1:nrow(db), y = db_m2m)\ndb_m2m &lt;- db[db_m2m, ]\ndb_o2o &lt;- db[db_o2o, ]\n\n# Expand interactions with multiple ensembl gene IDs\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"ToRemove\", c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")))\nfor(i in c(1:nrow(db_m2m))){\n  in_a &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_A[i], pattern = \"\\\\|\\\\|\"))\n  in_b &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_B[i], pattern = \"\\\\|\\\\|\"))\n  ab &lt;- expand.grid(\"Ensembl_Gene_Interactor_A\" = in_a, \"Ensembl_Gene_Interactor_B\" = in_b)\n  output &lt;- rbind(output, ab)\n}\nrm(in_a, in_b, ab, i)\noutput &lt;- output[-1, ]\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- rbind(db_o2o[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")], \n                output)\nrm(db, db_m2m, db_o2o, output)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/APID/9606_noISI_Q3_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)"
  },
  {
    "objectID": "scripts/ppi_network.html#biogrid",
    "href": "scripts/ppi_network.html#biogrid",
    "title": "Protein Protein Interaction (PPI) resources",
    "section": "",
    "text": "Code\n# Download data from Biogrid by species\ndir.create(path = \"./02_Datasets/BIOGRID/\")\ndownload.file(url= \"https://downloads.thebiogrid.org/Download/BioGRID/Release-Archive/BIOGRID-4.4.230/BIOGRID-ORGANISM-4.4.230.tab3.zip\",\n              destfile = \"./02_Datasets/BIOGRID/BIOGRID-ORGANISM-4.4.230.tab3.zip\") \nunzip(zipfile = \"./02_Datasets/BIOGRID/BIOGRID-ORGANISM-4.4.230.tab3.zip\", \n      exdir = \"./02_Datasets/BIOGRID/BIOGRID-ORGANISM-4.4.230.tab3\")\nunlink(x = \"./02_Datasets/BIOGRID/BIOGRID-ORGANISM-4.4.230.tab3.zip/\", recursive = TRUE)\n\n# Keep only Homo sapiens \nfn &lt;- list.files(path = \"./02_Datasets/BIOGRID/BIOGRID-ORGANISM-4.4.230.tab3/\", full.names = TRUE)\nfn_hs &lt;- fn[str_detect(string = fn, pattern = \"Homo_sapiens\")]\nfn_rm &lt;- fn[str_detect(string = fn, pattern = \"Homo_sapiens\", negate = TRUE)]\nunlink(x = fn_rm)\nrm(fn, fn_rm)\n\n# BIOGRID files to system variables \nSys.setenv(BIOGRID_HS = fn_hs)\nSys.setenv(BIOGRID_HS_4R = paste0(fn_hs, \".4R\", sep = \"\"))\n\n\n\n\nCode\n\n# Parse file to remove ' and # from file\nsed \"s/'//g\" $BIOGRID_HS &gt; $BIOGRID_HS_4R\nsed \"s/#//g\" $BIOGRID_HS_4R &gt; $BIOGRID_HS\n\n\n\n\nCode\n# Remove intermediate file\nunlink(x = paste0(fn_hs, \".4R\", sep = \"\"))\n\n\n\n\nCode\n# Homo sapiens interactions from BIOGRID\ndb &lt;- read.table(file = fn_hs, sep = \"\\t\", \n                 header = TRUE, stringsAsFactors = FALSE)\nrm(fn_hs)\n\n# Keep only physical interactions between Homo sapiens  \ndb &lt;- db[which(db$Experimental.System.Type == \"physical\"), ]\ndb &lt;- db[which(db$Organism.Name.Interactor.A == \"Homo sapiens\"), ]\ndb &lt;- db[which(db$Organism.Name.Interactor.B == \"Homo sapiens\"), ]\n\n# Interactions from Entrez to Ensembl Gene IDs\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = entrez_to_ensembl$Ensembl_GeneID[match(x = db$Entrez.Gene.Interactor.A, table = entrez_to_ensembl$Entrez_ID)], \n                 Ensembl_Gene_Interactor_B = entrez_to_ensembl$Ensembl_GeneID[match(x = db$Entrez.Gene.Interactor.B, table = entrez_to_ensembl$Entrez_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Separate into interactions with a single and multiple Ensembl Gene IDs\ndb_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n\ndb_o2o &lt;- setdiff(x = 1:nrow(db), y = db_m2m)\ndb_m2m &lt;- db[db_m2m, ]\ndb_o2o &lt;- db[db_o2o, ]\n\n# Expand interactions with multiple ensembl gene IDs\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"ToRemove\", c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")))\nfor(i in c(1:nrow(db_m2m))){\n  in_a &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_A[i], pattern = \"\\\\|\\\\|\"))\n  in_b &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_B[i], pattern = \"\\\\|\\\\|\"))\n  ab &lt;- expand.grid(\"Ensembl_Gene_Interactor_A\" = in_a, \"Ensembl_Gene_Interactor_B\" = in_b)\n  output &lt;- rbind(output, ab)\n  \n}\nrm(in_a, in_b, ab, i)\noutput &lt;- output[-1, ]\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- rbind(db_o2o[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")], \n                output)\nrm(db, db_m2m, db_o2o, output)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/BIOGRID/BIOGRID-ORGANISM-4.4.230.tab3_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)"
  },
  {
    "objectID": "scripts/ppi_network.html#bioplex",
    "href": "scripts/ppi_network.html#bioplex",
    "title": "Protein Protein Interaction (PPI) resources",
    "section": "",
    "text": "Code\n# Data download\ndir.create(path = \"./02_Datasets/BIOPLEX/\")\n\n\n# Bioplex version 3.0 # \n# Same name different file size for HCT116\ndownload.file(url = \"https://bioplex.hms.harvard.edu/data/BioPlex_293T_Network_10K_Dec_2019.tsv\",\n                            destfile = \"./02_Datasets/BIOPLEX/BioPlex_293T_Network_10K_Dec_2019.tsv\")\ndownload.file(url = \"https://bioplex.hms.harvard.edu/data/BioPlex_HCT116_Network_5.5K_Dec_2019.tsv\",\n              destfile = \"./02_Datasets/BIOPLEX/BioPlex_HCT116_Network_5.5K_Dec_2019.tsv\")\n\n\n\n\n\n\nCode\n# Bioplex\ndb &lt;- read.table(file = \"./02_Datasets/BIOPLEX/BioPlex_293T_Network_10K_Dec_2019.tsv\", sep = \"\\t\", header = TRUE)\n\n# Remove isoform info to mapp Uniprot ID\ndb$UniprotA &lt;- sapply(str_split(string = db$UniprotA, pattern = \"-\"), \"[\", 1)\ndb$UniprotB &lt;- sapply(str_split(string = db$UniprotB, pattern = \"-\"), \"[\", 1)\n\n# Mapping through uniprot\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$UniprotA, table = uniprot_to_ensembl$Uniprot_ID)],\n                 Ensembl_Gene_Interactor_B = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$UniprotB, table = uniprot_to_ensembl$Uniprot_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Separate into interactions with a single and multiple Ensembl Gene IDs\ndb_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n\ndb_o2o &lt;- setdiff(x = 1:nrow(db), y = db_m2m)\ndb_m2m &lt;- db[db_m2m, ]\ndb_o2o &lt;- db[db_o2o, ]\n\n# Expand interactions with multiple ensembl gene IDs\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"ToRemove\", c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")))\nfor(i in c(1:nrow(db_m2m))){\n  in_a &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_A[i], pattern = \"\\\\|\\\\|\"))\n  in_b &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_B[i], pattern = \"\\\\|\\\\|\"))\n  ab &lt;- expand.grid(\"Ensembl_Gene_Interactor_A\" = in_a, \"Ensembl_Gene_Interactor_B\" = in_b)\n  output &lt;- rbind(output, ab)\n}\nrm(in_a, in_b, ab, i)\noutput &lt;- output[-1, ]\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- rbind(db_o2o[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")], \n                output)\nrm(db, db_m2m, db_o2o, output)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/BIOPLEX/BioPlex_293T_Network_10K_Dec_2019_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)\n\n\n\n\n\n\n\nCode\n# Bioplex\ndb &lt;- read.table(file = \"./02_Datasets/BIOPLEX/BioPlex_HCT116_Network_5.5K_Dec_2019.tsv\", sep = \"\\t\", header = TRUE)\n\n# Remove isoform info to mapp Uniprot ID\ndb$UniprotA &lt;- sapply(str_split(string = db$UniprotA, pattern = \"-\"), \"[\", 1)\ndb$UniprotB &lt;- sapply(str_split(string = db$UniprotB, pattern = \"-\"), \"[\", 1)\n\n# Mapping through uniprot\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$UniprotA, table = uniprot_to_ensembl$Uniprot_ID)],\n                 Ensembl_Gene_Interactor_B = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$UniprotB, table = uniprot_to_ensembl$Uniprot_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Separate into interactions with a single and multiple Ensembl Gene IDs\ndb_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n\ndb_o2o &lt;- setdiff(x = 1:nrow(db), y = db_m2m)\ndb_m2m &lt;- db[db_m2m, ]\ndb_o2o &lt;- db[db_o2o, ]\n\n# Expand interactions with multiple ensembl gene IDs\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"ToRemove\", c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")))\nfor(i in c(1:nrow(db_m2m))){\n  in_a &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_A[i], pattern = \"\\\\|\\\\|\"))\n  in_b &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_B[i], pattern = \"\\\\|\\\\|\"))\n  ab &lt;- expand.grid(\"Ensembl_Gene_Interactor_A\" = in_a, \"Ensembl_Gene_Interactor_B\" = in_b)\n  output &lt;- rbind(output, ab)\n}\nrm(in_a, in_b, ab, i)\noutput &lt;- output[-1, ]\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- rbind(db_o2o[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")], \n                output)\nrm(db, db_m2m, db_o2o, output)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/BIOPLEX/BioPlex_HCT116_Network_5.5K_Dec_2019_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)"
  },
  {
    "objectID": "scripts/ppi_network.html#corum",
    "href": "scripts/ppi_network.html#corum",
    "title": "Protein Protein Interaction (PPI) resources",
    "section": "",
    "text": "Code\ndir.create(\"./02_Datasets/CORUM/\")\n\n# Database is now (Feb 2024) online !\n\n# All complexes\ndownload.file(\"https://mips.helmholtz-muenchen.de/corum/download/releases/current/allComplexes.txt.zip\", \n              destfile = \"./02_Datasets/CORUM/allComplex.zip\")\n\n# Human complexes\ndownload.file(\"https://mips.helmholtz-muenchen.de/corum/download/releases/current/humanComplexes.txt.zip\", \n              destfile = \"./02_Datasets/CORUM/humanComplexes.txt.zip\")\n\n# Partial complexes\ndownload.file(\"https://mips.helmholtz-muenchen.de/corum/download/releases/current/partialComplexes.txt.zip\", \n              destfile = \"./02_Datasets/CORUM/partialComplexes.txt.zip\")\n\n# Unzip files\ngunzip(zipfile = \"./02_Datasets/CORUM/allComplexes.txt.zip\", remove = TRUE)\ngunzip(zipfile = \"./02_Datasets/CORUM/humanComplexes.txt.zip\", remove = TRUE)\ngunzip(zipfile = \"./02_Datasets/CORUM/partialComplexes.txt.zip\", remove = TRUE)\n\nSys.setenv(CORUM_ALL = \"./02_Datasets/CORUM/allComplexes.txt\")\nSys.setenv(CORUM_ALL_TMP = \"./02_Datasets/CORUM/allComplexes_tmp.txt\")\n\nSys.setenv(CORUM_HUM = \"./02_Datasets/CORUM/humanComplexes.txt\")\nSys.setenv(CORUM_HUM_TMP = \"./02_Datasets/CORUM/humanComplexes_tmp.txt\")\n\nSys.setenv(CORUM_PAR = \"./02_Datasets/CORUM/partialComplexes.txt\")\nSys.setenv(CORUM_PAR_TMP = \"./02_Datasets/CORUM/partialComplexes_tmp.txt\")\n\n\n\n\nCode\n\n# Parse file to remove ' from file\nsed \"s/'//g\" $CORUM_ALL &gt; $CORUM_ALL_TMP\nsed \"s/'//g\" $CORUM_HUM &gt; $CORUM_HUM_TMP\nsed \"s/'//g\" $CORUM_PAR &gt; $CORUM_PAR_TMP\n\n\n\n\nCode\n# Remove temporal file and rename\nunlink(x = \"./02_Datasets/CORUM/allComplexes.txt\")\nunlink(x = \"./02_Datasets/CORUM/humanComplexes.txt\")\nunlink(x = \"./02_Datasets/CORUM/partialComplexes.txt\")\n\nfile.rename(from = \"./02_Datasets/CORUM/allComplexes_tmp.txt\", to = \"./02_Datasets/CORUM/allComplexes.txt\")\nfile.rename(from = \"./02_Datasets/CORUM/humanComplexes_tmp.txt\", to = \"./02_Datasets/CORUM/humanComplexes.txt\")\nfile.rename(from = \"./02_Datasets/CORUM/partialComplexes_tmp.txt\", to = \"./02_Datasets/CORUM/partialComplexes.txt\")\n\n\n\n\n\n\nCode\n# CORUM\ndb &lt;- read.table(file = \"./02_Datasets/CORUM/allComplexes.txt\", sep = \"\\t\", header = TRUE)\n\n# Rename column names \ncolnames(db) &lt;- str_replace_all(string = colnames(db), pattern = \"\\\\.\", replacement = \"_\")\n\n# Reduce to human interactions\ndb &lt;- db[which(db$Organism == \"Human\"), ]\n\n# From complexes to pairs of interactions\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, \n                 dimnames = list(\"RemoveMe\", c(\"Interactor_A\", \"Interactor_B\")))\n\nfor(i in 1:nrow(db)){\n  ci &lt;- unlist(str_split(string = db$subunits_UniProt_IDs_[i], pattern = \";\"))\n  if(length(ci) &gt; 0){\n  output &lt;- rbind(output, expand.grid(\"Interactor_A\" = ci, \"Interactor_B\" = ci))  \n  }\n  rm(ci)\n}\nrm(i)\noutput &lt;- output[-1, ]\nrm(db)\ndb &lt;- output\nrm(output)\nrownames(db) &lt;- 1:nrow(db)\n\n# Add ensembl annotations\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Interactor_A, table = uniprot_to_ensembl$Uniprot_ID)],\n                 Ensembl_Gene_Interactor_B = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Interactor_B, table = uniprot_to_ensembl$Uniprot_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Separate into interactions with a single and multiple Ensembl Gene IDs\ndb_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n\ndb_o2o &lt;- setdiff(x = 1:nrow(db), y = db_m2m)\ndb_m2m &lt;- db[db_m2m, ]\ndb_o2o &lt;- db[db_o2o, ]\n\n# Expand interactions with multiple ensembl gene IDs\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"ToRemove\", c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")))\nfor(i in c(1:nrow(db_m2m))){\n  in_a &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_A[i], pattern = \"\\\\|\\\\|\"))\n  in_b &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_B[i], pattern = \"\\\\|\\\\|\"))\n  ab &lt;- expand.grid(\"Ensembl_Gene_Interactor_A\" = in_a, \"Ensembl_Gene_Interactor_B\" = in_b)\n  output &lt;- rbind(output, ab)\n}\nrm(in_a, in_b, ab, i)\noutput &lt;- output[-1, ]\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- rbind(db_o2o[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")], \n                output)\nrm(db, db_m2m, db_o2o, output)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/CORUM/allComplexes_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)\n\n\n\n\n\n\n\nCode\n# CORUM\ndb &lt;- read.table(file = \"./02_Datasets/CORUM/humanComplexes.txt\", sep = \"\\t\", header = TRUE)\n\n# Rename column names \ncolnames(db) &lt;- str_replace_all(string = colnames(db), pattern = \"\\\\.\", replacement = \"_\")\n\n# Reduce to human interactions\ndb &lt;- db[which(db$Organism == \"Human\"), ]\n\n# From complexes to pairs of interactions\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"RemoveMe\", c(\"Interactor_A\", \"Interactor_B\")))\nfor(i in 1:nrow(db)){\n  ci &lt;- unlist(str_split(string = db$subunits_UniProt_IDs_[i], pattern = \";\"))\n  if(length(ci) &gt; 0){\n  output &lt;- rbind(output, expand.grid(\"Interactor_A\" = ci, \"Interactor_B\" = ci))  \n  }\n  rm(ci)\n}\nrm(i)\noutput &lt;- output[-1, ]\nrm(db)\ndb &lt;- output\nrm(output)\nrownames(db) &lt;- 1:nrow(db)\n\n# Add ensembl annotations\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Interactor_A, table = uniprot_to_ensembl$Uniprot_ID)],\n                 Ensembl_Gene_Interactor_B = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Interactor_B, table = uniprot_to_ensembl$Uniprot_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Separate into interactions with a single and multiple Ensembl Gene IDs\ndb_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n\ndb_o2o &lt;- setdiff(x = 1:nrow(db), y = db_m2m)\ndb_m2m &lt;- db[db_m2m, ]\ndb_o2o &lt;- db[db_o2o, ]\n\n# Expand interactions with multiple ensembl gene IDs\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"ToRemove\", c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")))\nfor(i in c(1:nrow(db_m2m))){\n  in_a &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_A[i], pattern = \"\\\\|\\\\|\"))\n  in_b &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_B[i], pattern = \"\\\\|\\\\|\"))\n  ab &lt;- expand.grid(\"Ensembl_Gene_Interactor_A\" = in_a, \"Ensembl_Gene_Interactor_B\" = in_b)\n  output &lt;- rbind(output, ab)\n}\nrm(in_a, in_b, ab, i)\noutput &lt;- output[-1, ]\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- rbind(db_o2o[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")], \n                output)\nrm(db, db_m2m, db_o2o, output)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/CORUM/humanComplexes_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)\n\n\n\n\n\n\n\nCode\n# CORUM\ndb &lt;- read.table(file = \"./02_Datasets/CORUM/partialComplexes.txt\", sep = \"\\t\", header = TRUE)\n\n# Rename column names \ncolnames(db) &lt;- str_replace_all(string = colnames(db), pattern = \"\\\\.\", replacement = \"_\")\n\n# Reduce to human interactions\ndb &lt;- db[which(db$Organism == \"Human\"), ]\n\n# From complexes to pairs of interactions\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"RemoveMe\", c(\"Interactor_A\", \"Interactor_B\")))\nfor(i in 1:nrow(db)){\n  ci &lt;- unlist(str_split(string = db$subunits_UniProt_IDs_[i], pattern = \";\"))\n  if(length(ci) &gt; 0){\n  output &lt;- rbind(output, expand.grid(\"Interactor_A\" = ci, \"Interactor_B\" = ci))  \n  }\n  rm(ci)\n}\nrm(i)\noutput &lt;- output[-1, ]\nrm(db)\ndb &lt;- output\nrm(output)\nrownames(db) &lt;- 1:nrow(db)\n\n# Add ensembl annotations\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Interactor_A, table = uniprot_to_ensembl$Uniprot_ID)],\n                 Ensembl_Gene_Interactor_B = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Interactor_B, table = uniprot_to_ensembl$Uniprot_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Separate into interactions with a single and multiple Ensembl Gene IDs\ndb_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n\ndb_o2o &lt;- setdiff(x = 1:nrow(db), y = db_m2m)\ndb_m2m &lt;- db[db_m2m, ]\ndb_o2o &lt;- db[db_o2o, ]\n\n# Expand interactions with multiple ensembl gene IDs\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"ToRemove\", c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")))\nfor(i in c(1:nrow(db_m2m))){\n  in_a &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_A[i], pattern = \"\\\\|\\\\|\"))\n  in_b &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_B[i], pattern = \"\\\\|\\\\|\"))\n  ab &lt;- expand.grid(\"Ensembl_Gene_Interactor_A\" = in_a, \"Ensembl_Gene_Interactor_B\" = in_b)\n  output &lt;- rbind(output, ab)\n}\nrm(in_a, in_b, ab, i)\noutput &lt;- output[-1, ]\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- rbind(db_o2o[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")], \n                output)\nrm(db, db_m2m, db_o2o, output)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/CORUM/partialComplexes_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)"
  },
  {
    "objectID": "scripts/ppi_network.html#hitpredict",
    "href": "scripts/ppi_network.html#hitpredict",
    "title": "Protein Protein Interaction (PPI) resources",
    "section": "",
    "text": "Code\n\n# Download interactions - # August 2023 last update.\n# You require to write an email to ashwini@combinatics.com to request access \n# Just send name, affiliation and brief description of use to get access link.\n# tar zxvf ./02_Datasets/HITPREDICT/H_sapiens_interactions.txt.tgz\n# tar zxvf ./02_Datasets/HITPREDICT/HitPredict_interactions.txt.tgz\n\n\n\n\nCode\n# HitPredict latest\ndb &lt;- read.table(file = \"./02_Datasets/HITPREDICT/H_sapiens_interactions.txt\", sep = \"\\t\", header = TRUE, skip = 4)\n\n# Mapping through uniprot\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Uniprot1, table = uniprot_to_ensembl$Uniprot_ID)],\n                 Ensembl_Gene_Interactor_B = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Uniprot2, table = uniprot_to_ensembl$Uniprot_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Separate into interactions with a single and multiple Ensembl Gene IDs\ndb_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n\ndb_o2o &lt;- setdiff(x = 1:nrow(db), y = db_m2m)\ndb_m2m &lt;- db[db_m2m, ]\ndb_o2o &lt;- db[db_o2o, ]\n\n# Expand interactions with multiple ensembl gene IDs\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"ToRemove\", c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")))\nfor(i in c(1:nrow(db_m2m))){\n  in_a &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_A[i], pattern = \"\\\\|\\\\|\"))\n  in_b &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_B[i], pattern = \"\\\\|\\\\|\"))\n  ab &lt;- expand.grid(\"Ensembl_Gene_Interactor_A\" = in_a, \"Ensembl_Gene_Interactor_B\" = in_b)\n  output &lt;- rbind(output, ab)\n}\nrm(in_a, in_b, ab, i)\noutput &lt;- output[-1, ]\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- rbind(db_o2o[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")], \n                output)\nrm(db, db_m2m, db_o2o, output)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/HITPREDICT/H_sapiens_interactions_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)"
  },
  {
    "objectID": "scripts/ppi_network.html#huri",
    "href": "scripts/ppi_network.html#huri",
    "title": "Protein Protein Interaction (PPI) resources",
    "section": "",
    "text": "Code\ndir.create(path = \"./02_Datasets/HURI/\")\ndownload.file(url = \"http://www.interactome-atlas.org/data/HuRI.tsv\",\n              destfile = \"./02_Datasets/HURI/HuRI.tsv\")\n\ndownload.file(url = \"http://www.interactome-atlas.org/data/HI-union.tsv\", \n              destfile = \"./02_Datasets/HURI/HI-union.tsv\")\n\ndownload.file(url = \"http://www.interactome-atlas.org/data/Test_space_screens-19.tsv\", \n              destfile = \"./02_Datasets/HURI/Test_space_screens-19.tsv\")\n\ndownload.file(url = \"http://www.interactome-atlas.org/data/Lit-BM.tsv\", \n              destfile = \"./02_Datasets/HURI/Lit-BM.tsv\")\n\ndownload.file(url = \"http://www.interactome-atlas.org/data/Yang-16.tsv\", \n              destfile = \"./02_Datasets/HURI/Yang-16.tsv\")\n\ndownload.file(url = \"http://www.interactome-atlas.org/data/HI-II-14.tsv\", \n              destfile = \"./02_Datasets/HURI/HI-II-14.tsv\")\n\ndownload.file(url = \"http://www.interactome-atlas.org/data/Venkatesan-09.tsv\", \n              destfile = \"./02_Datasets/HURI/Venkatesan-09.tsv\")\n\ndownload.file(url = \"http://www.interactome-atlas.org/data/H-I-05.tsv\",\n              destfile = \"./02_Datasets/HURI/H-I-05.tsv\")\n\ndownload.file(url = \"http://www.interactome-atlas.org/data/Yu-11.tsv\",\n              destfile = \"./02_Datasets/HURI/Yu-11.tsv\")\n\nfn &lt;- list.files(path = \"./02_Datasets/HURI/\", full.names = TRUE)\n\n\n\n\nCode\nfor (i in c(1:length(fn))){\n  \n  # HuRI\n  db_ens &lt;- read.table(file = fn[i], sep = \"\\t\", header = FALSE)\n\n  # Remove self interactions\n  mark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\n  if(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\n  rm(mark_self)\n\n  # Re-order interactions to remove duplicates\n  db_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\n  db_ens &lt;- unique(db_ens_order) \n  rm(db_ens_order)\n\n  out_name &lt;- paste0(str_replace(string = fn[i], \n                                 pattern = \".tsv\", \n                                 replacement = \"\"), \n                     \"_EnsemblGeneID.txt\", collapse = \"\")\n\n  # Save as tab delimited file \n  write.table(x = db_ens, \n              file = out_name, \n              sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)\n  rm(db_ens, out_name)\n}\nrm(fn, i)"
  },
  {
    "objectID": "scripts/ppi_network.html#intact",
    "href": "scripts/ppi_network.html#intact",
    "title": "Protein Protein Interaction (PPI) resources",
    "section": "",
    "text": "Code\n# Data download\ndir.create(path = \"./02_Datasets/INTACT/\")\ndownload.file(url = \"https://ftp.ebi.ac.uk/pub/databases/intact/current/psimitab/intact.zip\",\n              destfile = \"./02_Datasets/INTACT/intact.zip\") \nunzip(zipfile = \"./02_Datasets/INTACT/intact.zip\", exdir = \"./02_Datasets/INTACT/\")\nunlink(x = \"./02_Datasets/INTACT/intact.zip\")\n\n# INTACT files to system variables \nSys.setenv(INTACT = \"./02_Datasets/INTACT/intact.txt\")\nSys.setenv(INTACT_TMP = \"./02_Datasets/INTACT/intact_tmp.txt\")\n\n\n\n\nCode\n\n# Parse file to remove ' and # from file\nsed \"s/'//g\" $INTACT &gt; $INTACT_TMP\nsed \"s/#//g\" $INTACT_TMP &gt; $INTACT\n\n\n\n\nCode\n# Remove intermediate files\nunlink(x = \"./02_Datasets/INTACT/intact_tmp.txt\")\n\n\n\n\nCode\n# Intact db\ndb &lt;- read.table(file = \"./02_Datasets/INTACT/intact.txt\", sep = \"\\t\", quote = \"\", header = TRUE)\n\n# Replace \".\" from colnames \ncolnames(db) &lt;- str_replace_all(string = colnames(db), pattern = \"\\\\.\\\\.\", replacement = \".\")\ncolnames(db) &lt;- str_replace_all(string = colnames(db), pattern = \"\\\\.\", replacement = \"_\")\n\n# Only within human interactions\nhsap &lt;- intersect(which(str_detect(string = db$Taxid_interactor_A, pattern = \"taxid:9606\") == TRUE), \n                  which(str_detect(string = db$Taxid_interactor_B, pattern = \"taxid:9606\") == TRUE))\ndb &lt;- db[hsap, ]\nrm(hsap)\n\n# Mapping through uniprot\nuni &lt;- intersect(which(str_detect(string = db$ID_s_interactor_A, pattern = \"uniprotkb\") == TRUE),\n                 which(str_detect(string = db$ID_s_interactor_B, pattern = \"uniprotkb\") == TRUE))\ndb &lt;- db[uni, ]\nrm(uni)\ndb$ID_s_interactor_A &lt;- str_replace(string = db$ID_s_interactor_A, pattern = \"uniprotkb:\", replacement = \"\")\ndb$ID_s_interactor_B &lt;- str_replace(string = db$ID_s_interactor_B, pattern = \"uniprotkb:\", replacement = \"\")\n\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$ID_s_interactor_A, table = uniprot_to_ensembl$Uniprot_ID)],\n                 Ensembl_Gene_Interactor_B = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$ID_s_interactor_B, table = uniprot_to_ensembl$Uniprot_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Separate into interactions with a single and multiple Ensembl Gene IDs\ndb_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n\ndb_o2o &lt;- setdiff(x = 1:nrow(db), y = db_m2m)\ndb_m2m &lt;- db[db_m2m, ]\ndb_o2o &lt;- db[db_o2o, ]\n\n# Expand interactions with multiple ensembl gene IDs\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"ToRemove\", c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")))\nfor(i in c(1:nrow(db_m2m))){\n  in_a &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_A[i], pattern = \"\\\\|\\\\|\"))\n  in_b &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_B[i], pattern = \"\\\\|\\\\|\"))\n  ab &lt;- expand.grid(\"Ensembl_Gene_Interactor_A\" = in_a, \"Ensembl_Gene_Interactor_B\" = in_b)\n  output &lt;- rbind(output, ab)\n}\nrm(in_a, in_b, ab, i)\noutput &lt;- output[-1, ]\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- rbind(db_o2o[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")], \n                output)\nrm(db, db_m2m, db_o2o, output)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/INTACT/intact_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)"
  },
  {
    "objectID": "scripts/ppi_network.html#mint",
    "href": "scripts/ppi_network.html#mint",
    "title": "Protein Protein Interaction (PPI) resources",
    "section": "",
    "text": "Code\n# Data download\ndir.create(path = \"./02_Datasets/MINT/\")\n\ndownload.file(url = \"http://www.ebi.ac.uk/Tools/webservices/psicquic/mint/webservices/current/search/query/species:human\",\n              destfile = \"./02_Datasets/MINT/species_human.txt\")\n\nSys.setenv(MINT = \"./02_Datasets/MINT/species_human.txt\")\nSys.setenv(MINT_4R = \"./02_Datasets/MINT/species_human_tmp.txt\")\n\n\n\n\nCode\n\n# Parse file to remove ' and # from file\nsed \"s/'//g\" $MINT &gt; $MINT_4R\nsed \"s/#//g\" $MINT_4R &gt; $MINT\n\n\n\n\nCode\n# Remove temporal file\nunlink(x = \"./02_Datasets/MINT/species_human_tmp.txt\")\n\n\n\n\nCode\n# Mint\ndb &lt;- read.delim(\"./02_Datasets/MINT/species_human.txt\", sep = \"\\t\", quote = NULL, header = FALSE, stringsAsFactors = FALSE)\n\n# Rename a few columns\ncolnames(db)[1:2] &lt;- c(\"Interactor_A\", \"Interactor_B\")\ncolnames(db)[10:11] &lt;- c(\"Taxid_interactor_A\", \"Taxid_interactor_B\")\n\n# Only within human interactions\nhsap &lt;- intersect(which(str_detect(string = db$Taxid_interactor_A, pattern = \"taxid:9606\") == TRUE), \n                  which(str_detect(string = db$Taxid_interactor_B, pattern = \"taxid:9606\") == TRUE))\ndb &lt;- db[hsap, ]\nrm(hsap)\n\n# Mapping through uniprot\nuni &lt;- intersect(which(str_detect(string = db$Interactor_A, pattern = \"uniprotkb\") == TRUE),\n                 which(str_detect(string = db$Interactor_B, pattern = \"uniprotkb\") == TRUE))\ndb &lt;- db[uni, ]\nrm(uni)\ndb$Interactor_A &lt;- str_replace(string = db$Interactor_A, pattern = \"uniprotkb:\", replacement = \"\")\ndb$Interactor_B &lt;- str_replace(string = db$Interactor_B, pattern = \"uniprotkb:\", replacement = \"\")\n\n# Mapping through uniprot\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Interactor_A, table = uniprot_to_ensembl$Uniprot_ID)],\n                 Ensembl_Gene_Interactor_B = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Interactor_B, table = uniprot_to_ensembl$Uniprot_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Separate into interactions with a single and multiple Ensembl Gene IDs\ndb_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n\ndb_o2o &lt;- setdiff(x = 1:nrow(db), y = db_m2m)\ndb_m2m &lt;- db[db_m2m, ]\ndb_o2o &lt;- db[db_o2o, ]\n\n# Expand interactions with multiple ensembl gene IDs\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"ToRemove\", c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")))\nfor(i in c(1:nrow(db_m2m))){\n  in_a &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_A[i], pattern = \"\\\\|\\\\|\"))\n  in_b &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_B[i], pattern = \"\\\\|\\\\|\"))\n  ab &lt;- expand.grid(\"Ensembl_Gene_Interactor_A\" = in_a, \"Ensembl_Gene_Interactor_B\" = in_b)\n  output &lt;- rbind(output, ab)\n}\nrm(in_a, in_b, ab, i)\noutput &lt;- output[-1, ]\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- rbind(db_o2o[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")], \n                output)\nrm(db, db_m2m, db_o2o, output)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/MINT/species_human_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)"
  },
  {
    "objectID": "scripts/ppi_network.html#reactome",
    "href": "scripts/ppi_network.html#reactome",
    "title": "Protein Protein Interaction (PPI) resources",
    "section": "",
    "text": "Code\n# Data download\ndir.create(path = \"./02_Datasets/REACTOME/\")\ndownload.file(url = \"https://reactome.org/download/current/interactors/reactome.homo_sapiens.interactions.tab-delimited.txt\",\n              destfile = \"./02_Datasets/REACTOME/reactome.homo_sapiens.interactions.tab-delimited.txt\") \n\n\n# REACTOME files to system variables \nSys.setenv(REACTOME = \"./02_Datasets/REACTOME/reactome.homo_sapiens.interactions.tab-delimited.txt\")\nSys.setenv(REACTOME_TMP = \"./02_Datasets/REACTOME/reactome.homo_sapiens.interactions.tab-delimited_tmp.txt\")\n\n\n\n\nCode\n\n# Parse file to remove ' and # from file\nsed \"s/'//g\" $REACTOME &gt; $REACTOME_TMP\nsed \"s/#//g\" $REACTOME_TMP &gt; $REACTOME\n\n\n\n\nCode\n# Remove intermediate files\nunlink(x = \"./02_Datasets/REACTOME/reactome.homo_sapiens.interactions.tab-delimited_tmp.txt\")\n\n\n\n\nCode\n# Reactome\ndb &lt;- read.table(file = \"./02_Datasets/REACTOME/reactome.homo_sapiens.interactions.tab-delimited.txt\", sep = \"\\t\", quote = \"\", header = TRUE)\n\n# Replace \".\" from colnames \ncolnames(db) &lt;- str_replace_all(string = colnames(db), pattern = \"\\\\.\", replacement = \"_\")\n\n# Mapping through uniprot\nuni &lt;- intersect(which(str_detect(string = db$Interactor_1_uniprot_id, pattern = \"uniprotkb\") == TRUE),\n                 which(str_detect(string = db$Interactor_2_uniprot_id, pattern = \"uniprotkb\") == TRUE))\ndb &lt;- db[uni, ]\nrm(uni)\ndb$Interactor_1_uniprot_id &lt;- str_replace(string = db$Interactor_1_uniprot_id, pattern = \"uniprotkb:\", replacement = \"\")\ndb$Interactor_2_uniprot_id &lt;- str_replace(string = db$Interactor_2_uniprot_id, pattern = \"uniprotkb:\", replacement = \"\")\n\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Interactor_1_uniprot_id, table = uniprot_to_ensembl$Uniprot_ID)],\n                 Ensembl_Gene_Interactor_B = uniprot_to_ensembl$Ensembl_GeneID[match(x = db$Interactor_2_uniprot_id, table = uniprot_to_ensembl$Uniprot_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Separate into interactions with a single and multiple Ensembl Gene IDs\ndb_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n\ndb_o2o &lt;- setdiff(x = 1:nrow(db), y = db_m2m)\ndb_m2m &lt;- db[db_m2m, ]\ndb_o2o &lt;- db[db_o2o, ]\n\n# Expand interactions with multiple ensembl gene IDs\noutput &lt;- matrix(NA, nrow = 1, ncol = 2, dimnames = list(\"ToRemove\", c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")))\nfor(i in c(1:nrow(db_m2m))){\n  in_a &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_A[i], pattern = \"\\\\|\\\\|\"))\n  in_b &lt;- unlist(str_split(string = db_m2m$Ensembl_Gene_Interactor_B[i], pattern = \"\\\\|\\\\|\"))\n  ab &lt;- expand.grid(\"Ensembl_Gene_Interactor_A\" = in_a, \"Ensembl_Gene_Interactor_B\" = in_b)\n  output &lt;- rbind(output, ab)\n}\nrm(in_a, in_b, ab, i)\noutput &lt;- output[-1, ]\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- rbind(db_o2o[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")], \n                output)\nrm(db, db_m2m, db_o2o, output)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/REACTOME/reactome.homo_sapiens.interactions.tab-delimited_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)"
  },
  {
    "objectID": "scripts/ppi_network.html#string",
    "href": "scripts/ppi_network.html#string",
    "title": "Protein Protein Interaction (PPI) resources",
    "section": "",
    "text": "Code\n# Data download\ndir.create(path = \"./02_Datasets/STRING/\")\n\ndownload.file(url = \"https://stringdb-downloads.org/download/protein.links.v12.0/9606.protein.links.v12.0.txt.gz\",\n              destfile = \"./02_Datasets/STRING/9606.protein.links.v12.0.txt.gz\")\n\ndownload.file(url = \"https://stringdb-downloads.org/download/protein.physical.links.v12.0/9606.protein.physical.links.v12.0.txt.gz\",\n              destfile = \"./02_Datasets/STRING/9606.protein.physical.links.v12.0.txt.gz\")\n\ngunzip(\"./02_Datasets/STRING/9606.protein.links.v12.0.txt.gz\", remove = TRUE)\ngunzip(\"./02_Datasets/STRING/9606.protein.physical.links.v12.0.txt.gz\", remove = TRUE)\n\n\n\n\n\n\nCode\n# String\ndb &lt;- read.table(file = \"./02_Datasets/STRING/9606.protein.links.v12.0.txt\", header = TRUE)\ndb$protein1 &lt;- str_replace(string = db$protein1, pattern = \"9606.\", replacement = \"\")\ndb$protein2 &lt;- str_replace(string = db$protein2, pattern = \"9606.\", replacement = \"\")\n\n# Mapping through protein ID\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = proteinID_to_ensembl$Ensembl_GeneID[match(x = db$protein1, table = proteinID_to_ensembl$Protein_ID)],\n                 Ensembl_Gene_Interactor_B = proteinID_to_ensembl$Ensembl_GeneID[match(x = db$protein2, table = proteinID_to_ensembl$Protein_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Check if there are multiple Ensembl Gene IDs\n#db_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n#                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n#length(db_m2m)\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- db[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")]\nrm(db)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/STRING/9606.protein.links.v12.0_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)\n\n\n\n\n\n\n\nCode\n# String\ndb &lt;- read.table(file = \"./02_Datasets/STRING/9606.protein.physical.links.v12.0.txt\", header = TRUE)\ndb$protein1 &lt;- str_replace(string = db$protein1, pattern = \"9606.\", replacement = \"\")\ndb$protein2 &lt;- str_replace(string = db$protein2, pattern = \"9606.\", replacement = \"\")\n\n# Mapping through protein ID\ndb &lt;- data.frame(db, \n                 Ensembl_Gene_Interactor_A = proteinID_to_ensembl$Ensembl_GeneID[match(x = db$protein1, table = proteinID_to_ensembl$Protein_ID)],\n                 Ensembl_Gene_Interactor_B = proteinID_to_ensembl$Ensembl_GeneID[match(x = db$protein2, table = proteinID_to_ensembl$Protein_ID)])\n\n# Remove interactions where either interactor cannot be mapped to Ensembl Gene IDs\nnm &lt;- unique(c(which(is.na(db$Ensembl_Gene_Interactor_A) == TRUE),\n               which(is.na(db$Ensembl_Gene_Interactor_B) == TRUE)))\nif(length(nm)&gt; 0){ db &lt;- db[-nm, ]}\nrm(nm)\n\n# Check if there are multiple Ensembl Gene IDs\n#db_m2m &lt;- unique(c(which(str_detect(string = db$Ensembl_Gene_Interactor_A, pattern = \"\\\\|\") == TRUE),\n#                   which(str_detect(string = db$Ensembl_Gene_Interactor_B, pattern = \"\\\\|\") == TRUE)))\n#length(db_m2m)\n\n# Combine interactions that map a single and multiple Ensembl Gene IDs \ndb_ens &lt;- db[, c(\"Ensembl_Gene_Interactor_A\", \"Ensembl_Gene_Interactor_B\")]\nrm(db)\n\n# Remove self interactions\nmark_self &lt;- apply(db_ens, 1, FUN = function(x) length(unique(x)))\nif(length(which(mark_self == 1))&gt; 0){db_ens &lt;- db_ens[-which(mark_self == 1), ]}\nrm(mark_self)\n\n# Re-order interactions to remove duplicates\ndb_ens_order &lt;- t(apply(db_ens, 1, FUN = function(x) x[order(x)]))\ndb_ens &lt;- unique(db_ens_order) \nrm(db_ens_order)\n\n# Convert to data frame\nrownames(db_ens) &lt;- 1:nrow(db_ens)\ndb_ens &lt;- as.data.frame(db_ens)\n\n# Save as tab delimited file \nwrite.table(x = db_ens, \n            file = \"./02_Datasets/STRING/9606.protein.physical.links.v12.0_EnsemblGeneID.txt\", \n            sep = \"\\t\", row.names = FALSE, col.names = FALSE, quote = FALSE)"
  },
  {
    "objectID": "scripts/ppi_network.html#overview-resources",
    "href": "scripts/ppi_network.html#overview-resources",
    "title": "Protein Protein Interaction (PPI) resources",
    "section": "",
    "text": "Code\n# List all protein protein interactions given in Ensembl Gene IDs\nfn &lt;- list.files(path = \"./02_Datasets/\", recursive = TRUE, pattern = \"EnsemblGeneID\", full.names = TRUE)\n\ngfn &lt;- sapply(str_split(string = fn, pattern = \"\\\\/\"), \"[\", 3)\ngfd &lt;- str_replace(string = sapply(str_split(string = fn, pattern = \"\\\\/\"), \"[\", 4), \n                   pattern = \"_EnsemblGeneID.txt\", replacement = \"\")\n\n# Relabel datasets # \nnames_datasets &lt;- data.frame(fn_sub = c(\"9606_noISI_Q3\", \n                                        \"BIOGRID-ORGANISM-Homo_sapiens-4.4.230.tab3\",\n                                        \"BioPlex_293T_Network_10K_Dec_2019\", \"BioPlex_HCT116_Network_5.5K_Dec_2019\",\n                                        \"allComplexes\", \"humanComplexes\", \"partialComplexes\", \n                                        \"H_sapiens_interactions\",\n                                        \"H-I-05\", \"HI-II-14\", \"HI-union\", \"HuRI\", \"Lit-BM\", \n                                        \"Test_space_screens-19\", \"Venkatesan-09\", \"Yang-16\", \"Yu-11\",\n                                        \"intact\", \n                                        \"species_human\",\n                                        \"reactome.homo_sapiens.interactions.tab-delimited\",\n                                        \"9606.protein.links.v12.0\", \"9606.protein.physical.links.v12.0\"),\n                             Dataset = c(\"APID\", \n                                         \"BIOGRID\", \n                                         \"BIOPLEX_293T\", \"BIOPLEX_HCT116\",\n                                         \"CORUM_All\", \"CORUM_human\", \"CORUM_partial\",  \n                                         \"HITPREDICT_latest\",\n                                         \"HURI_H-I-05\", \"HURI_HI-II-14\", \"HURI_HI-union\", \"HURI_HuRI\", \"HURI_Lit-BM\",\n                                         \"HURI_Test19\", \"HURI_Venkatesan\", \"HURI_Yang\", \"HURI_Yu\",\n                                         \"INTACT\", \n                                         \"MINT\", \n                                         \"REACTOME\",\n                                         \"STRING_Links\", \"STRING_Physical\"))\n\n# Obtain an overview of each\noutput &lt;- matrix(NA, length(fn), 4, \n                 dimnames = list(gfd, c(\"Genes\", \"Interactions\", \"Mean per gene\", \"Median per gene\")))\n\nfor (i in c(1:length(fn))){ \n  fni &lt;- read.table(file = fn[i], sep = \"\\t\", stringsAsFactors = FALSE)\n  output[i, 1] &lt;- length(unique(c(fni$V1, fni$V2)))\n  output[i, 2] &lt;- nrow(fni)\n  output[i, 3] &lt;- mean(table(c(fni$V1, fni$V2)))\n  output[i, 4] &lt;- median(table(c(fni$V1, fni$V2)))\n}\nrm(fni, i)\n\noutput &lt;- data.frame(Source = gfn, fn_sub = gfd, output)\noutput &lt;- merge(output, names_datasets, by = \"fn_sub\")\n\n\n\n\nCode\n# Number of genes\ng1 &lt;- ggplot(data = output, mapping = aes(x = Dataset, y = Genes, fill = Source, label = Genes)) + \n  geom_col() + geom_text(angle = 90, size = 3) + theme_classic() +\n  theme(legend.position = \"none\", \n        axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0))\n\n# Number of interactions\ng2 &lt;- ggplot(data = output, mapping = aes(x = Dataset, y = Interactions, \n                                          fill = Source, label = Interactions)) + \n  geom_col() + geom_text(angle = 90, size = 3) + theme_classic() +\n  theme(legend.position = \"none\", \n        axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0))\n\n# Mean interactions per gene\ng3 &lt;- ggplot(data = output, mapping = aes(x = Dataset, y = Mean.per.gene, \n                                          fill = Source)) + \n  geom_col() + theme_classic() +\n  theme(legend.position = \"none\", \n        axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0))\n\n# Median interactions per gene\ng4 &lt;- ggplot(data = output, mapping = aes(x = Dataset, y = Median.per.gene, \n                                          fill = Source)) + \n  geom_col() + theme_classic() +\n  theme(legend.position = \"none\", \n        axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0))\n\n# Overview\ng5 &lt;- ggplot(data = output, mapping = aes(x = log10(Interactions), \n                                          y = Genes, \n                                          color = Source, \n                                          size = Median.per.gene,\n                                          label = Dataset)) + \n  geom_point() + \n  geom_text_repel() + \n  theme_classic() + \n  scale_color_met_d(name = \"Signac\")\n\ng1\ng2\ng3\ng4\ng5\n\nrm(g1, g2, g3, g4, g5, output)"
  },
  {
    "objectID": "scripts/ppi_network.html#merged-ppi-network",
    "href": "scripts/ppi_network.html#merged-ppi-network",
    "title": "Protein Protein Interaction (PPI) resources",
    "section": "",
    "text": "Code\n# Create directory for merged PPI\ndir.create(path = \"./03_PPIMerged/\")\n\n\n\n\n\n\nCode\n# Combine all datasets\nPPIall &lt;- read.table(fn[1], header = FALSE)\n\nfor(i in c(2:length(fn))){\n  ppi &lt;- read.table(file = fn[i], header = FALSE)\n  PPIall &lt;- rbind(PPIall, ppi)\n  rm(ppi)\n}\n\n# Keep only unique interactions\nPPIall &lt;- unique(PPIall)\n\nfn_ppi &lt;- paste0(c(\"./03_PPIMerged/\",\n                   \"MergedPPI_\",\n                   paste0(sapply(str_split(date(), \" \"), \"[\", c(5, 2)), collapse = \"\"),\n                   # unique(gfn), # Optional to include names of datasets in output file\n                   \".txt\"),\n                 collapse = \"\")\n\nwrite.table(x = PPIall, file = fn_ppi, sep = \"\\t\", \n            quote = FALSE, row.names = FALSE, col.names = FALSE)\n\nrm(PPIall)\n\n\n\n\nCode\n# Combine datasets except string links\nfn &lt;- setdiff(fn, y = \"./02_Datasets/STRING/9606.protein.links.v12.0_EnsemblGeneID.txt\")\n\nPPIall &lt;- read.table(fn[1], header = FALSE)\n\nfor(i in c(2:length(fn))){\n  ppi &lt;- read.table(file = fn[i], header = FALSE)\n  PPIall &lt;- rbind(PPIall, ppi)\n  rm(ppi)\n}\n\n# Keep only unique interactions\nPPIall &lt;- unique(PPIall)\n\nfn_ppi &lt;- paste0(c(\"./03_PPIMerged/\",\n                   \"MergedPPI_\",\n                   paste0(sapply(str_split(date(), \" \"), \"[\", c(5, 2)), collapse = \"\"),\n                   # unique(gfn), # Optional to include names of datasets in output file\n                   \"_PIO_STRING.txt\"),\n                 collapse = \"\")\n\nwrite.table(x = PPIall, file = fn_ppi, sep = \"\\t\", \n            quote = FALSE, row.names = FALSE, col.names = FALSE)"
  },
  {
    "objectID": "scripts/ppi_network.html#references",
    "href": "scripts/ppi_network.html#references",
    "title": "Protein Protein Interaction (PPI) resources",
    "section": "",
    "text": "APID Alonso-Lopez, D., et al. (2019). “APID database: redefining protein-protein interaction experimental evidences and binary interactomes.” Database (Oxford) 2019.\nAPID Alonso-Lopez, D., et al. (2016). “APID interactomes: providing proteome-based interactomes with controlled quality for multiple species and derived networks.” Nucleic Acids Res 44(W1): W529-535.\nBIOGRID Oughtred, R., et al. (2021). “The BioGRID database: A comprehensive biomedical resource of curated protein, genetic, and chemical interactions.” Protein Sci 30(1): 187-200.\nBIOPLEX Huttlin, E. L., et al. (2021). “Dual proteome-scale networks reveal cell-specific remodeling of the human interactome.” Cell 184(11): 3022-3040 e3028.\nCORUM Tsitsiridis, G., et al. (2023). “CORUM: the comprehensive resource of mammalian protein complexes-2022.” Nucleic Acids Res 51(D1): D539-D545.\nCORUM Giurgiu, M., et al. (2019). “CORUM: the comprehensive resource of mammalian protein complexes-2019.” Nucleic Acids Res 47(D1): D559-D563.\nHITPREDICT Lopez, Y., et al. (2015). “HitPredict version 4: comprehensive reliability scoring of physical protein-protein interactions from more than 100 species.” Database (Oxford) 2015.\nHURI Luck, K., et al. (2020). “A reference map of the human binary protein interactome.” Nature 580(7803): 402-408.\nINTACT Orchard, S., et al. (2014). “The MIntAct project–IntAct as a common curation platform for 11 molecular interaction databases.” Nucleic Acids Res 42(Database issue): D358-363.\nMINT Licata, L., et al. (2012). “MINT, the molecular interaction database: 2012 update.” Nucleic Acids Res 40(Database issue): D857-861.\nREACTOME Gillespie, M., et al. (2022). “The reactome pathway knowledgebase 2022.” Nucleic Acids Res 50(D1): D687-D692.\nSTRING Szklarczyk, D., et al. (2023). “The STRING database in 2023: protein-protein association networks and functional enrichment analyses for any sequenced genome of interest.” Nucleic Acids Res 51(D1): D638-D646."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Extracting information from omics data workshop",
    "section": "",
    "text": "This site is for the Extracting information from omics data session, which is part of the Data-driven approaches to understanding dementia.\nYour can find the first step of the workshop here, or use the side-bar to navigate around.\n\n\n\nReusehttps://creativecommons.org/licenses/by-sa/4.0/"
  },
  {
    "objectID": "01-differential_expression.html",
    "href": "01-differential_expression.html",
    "title": "Extracting information from omics data workshop",
    "section": "",
    "text": "Code\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggthemes)\nlibrary(DESeq2)\nlibrary(tximport)\nlibrary(pheatmap)\nlibrary(gprofiler2)\nlibrary(clusterProfiler)\nlibrary(enrichplot)\nlibrary(DOSE)\nlibrary(ggrepel)\nlibrary(tibble)\nlibrary(purrr)\nlibrary(readr)\nlibrary(here)\nlibrary(apeglm)\nlibrary(biomaRt)\nlibrary(AnnotationHub)\nlibrary(memes)\nlibrary(TFBSTools)\nlibrary(JASPAR2024)\nlibrary(universalmotif)"
  },
  {
    "objectID": "01-differential_expression.html#load-libraries",
    "href": "01-differential_expression.html#load-libraries",
    "title": "Extracting information from omics data workshop",
    "section": "",
    "text": "Code\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggthemes)\nlibrary(DESeq2)\nlibrary(tximport)\nlibrary(pheatmap)\nlibrary(gprofiler2)\nlibrary(clusterProfiler)\nlibrary(enrichplot)\nlibrary(DOSE)\nlibrary(ggrepel)\nlibrary(tibble)\nlibrary(purrr)\nlibrary(readr)\nlibrary(here)\nlibrary(apeglm)\nlibrary(biomaRt)\nlibrary(AnnotationHub)\nlibrary(memes)\nlibrary(TFBSTools)\nlibrary(JASPAR2024)\nlibrary(universalmotif)"
  },
  {
    "objectID": "01-differential_expression.html#load-the-rna-seq-data",
    "href": "01-differential_expression.html#load-the-rna-seq-data",
    "title": "Extracting information from omics data workshop",
    "section": "Load the RNA-Seq data",
    "text": "Load the RNA-Seq data\nWe already pre-processed the RNA-Seq and ATAC-Seq data using nf-core/fetchngs, nf-core/rnaseq and nf-core/atacseq. We looked at the MultiQC reports to get an initial idea of the quality of the data.\n\n\nNow we’ll load the RNA-Seq data to start to get an impression of what might be special about the brain endothelial cells and see if we can re-produce some of the results from the manuscript.\nDo you know the difference between absolute and relative file paths..?\n\n\nCode\ntx2genefile = here::here('data/count_tables/tx2gene.tsv')\ntx2gene = read.delim(tx2genefile, header=FALSE)[, 1:3]\n\ndirectory_path &lt;- here::here(\"data/count_tables\")\nfiles = list.files(path = directory_path,pattern = \"quant.sf\", recursive = TRUE, full.names = TRUE)\n\ntxi = tximport(files, type=\"salmon\", tx2gene=tx2gene)\n\n\nreading in files with read_tsv\n\n\n1 2 3 4 5 6 7 8 9 \nsummarizing abundance\nsummarizing counts\nsummarizing length\n\n\nCode\nsamples = sapply(files, function(path) {basename(dirname(path))})\ncondition = sapply(files, function(path) {\n  folder_name &lt;- basename(dirname(path))\n  sub(\"([123]-.*)\", \"\", folder_name)\n})\n\ndata = data.frame(condition = condition)\nrownames(data) = samples\n\ndata\n\n\n\n\n\n\n\ncondition\n\n\n\n\nBR1-EC_bRNA\nBR\n\n\nBR2-EC_bRNA\nBR\n\n\nBR3-EC_bRNA\nBR\n\n\nLG1-EC_bRNA\nLG\n\n\nLG2-EC_bRNA\nLG\n\n\nLG3-EC_bRNA\nLG\n\n\nLV1-EC_bRNA\nLV\n\n\nLV2-EC_bRNA\nLV\n\n\nLV3-EC_bRNA\nLV\n\n\n\n\n\n\nWe use the DeSeq2 library to perform differential gene expression analysis and also to normalise our counts for making plots such as PCA, heatmaps .etc\n\n\nCode\ndds &lt;- DESeqDataSetFromTximport(txi, colData=data, design=~condition)\n\n\nWarning in DESeqDataSet(se, design = design, ignoreRank): some variables in\ndesign formula are characters, converting to factors\n\n\nusing counts and average transcript lengths from tximport\n\n\nCode\ndds &lt;- DESeq(dds)\n\n\nestimating size factors\n\n\nusing 'avgTxLength' from assays(dds), correcting for library size\n\n\nestimating dispersions\n\n\ngene-wise dispersion estimates\n\n\nmean-dispersion relationship\n\n\nfinal dispersion estimates\n\n\nfitting model and testing\n\n\nCode\nvsd &lt;- vst(dds, blind=TRUE)\n# this gives log2(n + 1)\nntd &lt;- normTransform(dds)\n\n\n\n\nCode\npcaData &lt;- plotPCA(vsd, intgroup=\"condition\", returnData=TRUE)\n\n\nusing ntop=500 top features by variance\n\n\nCode\npercentVar &lt;- round(100 * attr(pcaData, \"percentVar\"))\nggplot(pcaData, aes(PC1, PC2, color=condition)) +\n  geom_point(size=3) +\n  xlab(paste0(\"PC1: \",percentVar[1],\"% variance\")) +\n  ylab(paste0(\"PC2: \",percentVar[2],\"% variance\")) + \n  coord_fixed() +\n  theme_few()\n\n\n\n\n\nWe were worried about cell stress pathways as these samples were collected directly after FACs sorting. Let’s look at highly expressed genes in each condition and see if these are enriched in stress-related GO terms.\n\n\nCode\nselect &lt;- order(rowMeans(counts(dds,normalized=TRUE)),\n                decreasing=TRUE)[1:300]\ntop300 &lt;- as.data.frame(assay(ntd)[select,])\n\ngo_enrich = gost(rownames(top300), organism = \"mmusculus\",ordered_query = TRUE)\ngostplot(go_enrich, interactive = TRUE)\n\n\n\n\n\n\n\n\nCode\n# modify the g:Profiler data frame\ngp_mod = go_enrich$result[,c(\"query\", \"source\", \"term_id\",\n                                \"term_name\", \"p_value\", \"query_size\", \n                                \"intersection_size\", \"term_size\", \n                                \"effective_domain_size\")]\ngp_mod$GeneRatio = paste0(gp_mod$intersection_size,  \"/\", gp_mod$query_size)\ngp_mod$BgRatio = paste0(gp_mod$term_size, \"/\", gp_mod$effective_domain_size)\n\nnames(gp_mod) = c(\"Cluster\", \"Category\", \"ID\", \"Description\", \"p.adjust\", \n                    \"query_size\", \"Count\", \"term_size\", \"effective_domain_size\", \n                    \"GeneRatio\", \"BgRatio\")\n\nrow.names(gp_mod) = gp_mod$ID\n\n# define as enrichResult object\ngp_mod_enrich  = new(\"enrichResult\", result = gp_mod)\nenrichplot::dotplot(gp_mod_enrich)\n\n\n\n\n\n\nQ) What do you think? Do our cells seem stressed?\nNow lets look for genes enriched in brain endothelial cells compared to lung or liver…\n\n\nCode\nres = results(dds)\nresultsNames(dds)\n\n\n[1] \"Intercept\"          \"condition_LG_vs_BR\" \"condition_LV_vs_BR\"\n\n\nWe want genes that are overexpressed in brain compared to both lung and liver. In this set up this will be represented by genes that have a negative log2FoldChange in the comparisons named above.\n\nWhat kind of thresholds should we use for log2FoldChange and adjusted p value? Another visualization can help us to decide, let’s have a look at volcano plots for both comparisons..\n\n\n\nCode\nfoldchange=0.5\npval=0.05\n\nPlotVolcano &lt;-function(comparison){\n  de = lfcShrink(dds, coef=comparison, type=\"apeglm\")\n  resul = as.data.frame(de)\n  resul$geneID &lt;- rownames(resul)\n  de &lt;- merge(resul, tx2gene, by.x = \"geneID\", by.y = \"V2\", all.x = TRUE, all.y = FALSE)\n  \n  de = de %&gt;% dplyr::filter(!is.na(log2FoldChange)) %&gt;% dplyr::select(-V1) %&gt;% unique()\n  \n  # get numbers of diff genes for labelling\n  n_unchanged &lt;- de %&gt;% dplyr::filter(log2FoldChange &lt; foldchange & log2FoldChange &gt; -(foldchange)) %&gt;% nrow()\n  n_up &lt;- de %&gt;% dplyr::filter(log2FoldChange &gt;= foldchange & padj &lt; pval) %&gt;% nrow()\n  n_down &lt;- de %&gt;% dplyr::filter(log2FoldChange &lt;= -(foldchange) & padj &lt; pval) %&gt;% nrow()\n  \n  de$diffexpressed &lt;- paste0(\"Unchanged (\",n_unchanged,\")\")\n  de$diffexpressed[de$log2FoldChange &gt;= foldchange & de$padj &lt; pval] &lt;- paste0(\"Up (\",n_up,\")\")\n  de$diffexpressed[de$log2FoldChange &lt;= -(foldchange) & de$padj &lt; pval] &lt;- paste0(\"Down (\",n_down,\")\")\n  \n  # set colours vector\n  if (n_up == 0 & n_down == 0){\n      cvec = c(\"#84A1AB\")\n  } else if (n_up == 0){\n      cvec = c(\"#B02302\", \"#84A1AB\")\n  } else if (n_down == 0){\n      cvec = c(\"#84A1AB\", \"#61B002\")\n  } else {\n      cvec = c(\"#B02302\", \"#84A1AB\", \"#61B002\")\n  }\n  \n  # label genes that are differentially expressed\n  de$delabel &lt;- NA\n  de$delabel[de$diffexpressed != \"NO\"] &lt;- de$V3[de$diffexpressed != \"NO\"]\n  de=de[order(de$padj),]\n  \n  \n  # Volcano plot\n  ggplot(data=de, aes(x=log2FoldChange, y=-log10(padj), label=delabel)) +\n          geom_vline(xintercept=c(-(foldchange), foldchange), col=\"light grey\", linetype=\"dashed\") +\n          geom_hline(yintercept=-log10(pval), col=\"light grey\", linetype=\"dashed\") +\n          geom_point(aes(color=diffexpressed), alpha=0.5) +\n          geom_text_repel(data=de[1:50,],aes(x = log2FoldChange, y = -log10(padj),label=V3),max.overlaps=50) +\n          scale_color_manual(values=cvec) +\n          theme_few() +theme(aspect.ratio=1)\n}\n\n\n\n\nCode\nPlotVolcano(\"condition_LG_vs_BR\")\n\n\nusing 'apeglm' for LFC shrinkage. If used in published research, please cite:\n    Zhu, A., Ibrahim, J.G., Love, M.I. (2018) Heavy-tailed prior distributions for\n    sequence count data: removing the noise and preserving large differences.\n    Bioinformatics. https://doi.org/10.1093/bioinformatics/bty895\n\n\nWarning: Removed 7060 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\nCode\nPlotVolcano(\"condition_LV_vs_BR\")\n\n\nusing 'apeglm' for LFC shrinkage. If used in published research, please cite:\n    Zhu, A., Ibrahim, J.G., Love, M.I. (2018) Heavy-tailed prior distributions for\n    sequence count data: removing the noise and preserving large differences.\n    Bioinformatics. https://doi.org/10.1093/bioinformatics/bty895\n\n\nWarning: Removed 7471 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\nQ) Do these thresholds seem reasonable?\nLet’s look at genes that are overexpressed in brain compared to both lung and liver. We will perform the GO analysis again to see what kind of gene networks they are a part of.\n\n\n\nCode\nbrainliver = lfcShrink(dds, coef=\"condition_LV_vs_BR\", type=\"apeglm\") %&gt;%\n  as.data.frame() %&gt;%\n  filter(padj&lt;0.001 & log2FoldChange &lt;= -2) %&gt;%\n  rownames()\n\n\nusing 'apeglm' for LFC shrinkage. If used in published research, please cite:\n    Zhu, A., Ibrahim, J.G., Love, M.I. (2018) Heavy-tailed prior distributions for\n    sequence count data: removing the noise and preserving large differences.\n    Bioinformatics. https://doi.org/10.1093/bioinformatics/bty895\n\n\nCode\nbrainlung = lfcShrink(dds, coef=\"condition_LG_vs_BR\", type=\"apeglm\") %&gt;%\n  as.data.frame() %&gt;%\n  filter(padj&lt;0.001 & log2FoldChange &lt;= -2) %&gt;%\n  rownames()\n\n\nusing 'apeglm' for LFC shrinkage. If used in published research, please cite:\n    Zhu, A., Ibrahim, J.G., Love, M.I. (2018) Heavy-tailed prior distributions for\n    sequence count data: removing the noise and preserving large differences.\n    Bioinformatics. https://doi.org/10.1093/bioinformatics/bty895\n\n\nCode\nlength(brainlung)\n\n\n[1] 388\n\n\nCode\nlength(brainliver)\n\n\n[1] 743\n\n\nCode\n# get genes that appear in both lists\nbrain_enriched = intersect(brainlung,brainliver) %&gt;% unique()\nlength(brain_enriched)\n\n\n[1] 229\n\n\nCode\n# as a control set for later, lets pick out some liver enriched genes\nliver_enriched = lfcShrink(dds, coef=\"condition_LV_vs_BR\", type=\"apeglm\") %&gt;%\n  as.data.frame() %&gt;%\n  filter(padj&lt;0.001 & log2FoldChange &gt;= 2) %&gt;%\n  rownames() %&gt;% unique\n\n\nusing 'apeglm' for LFC shrinkage. If used in published research, please cite:\n    Zhu, A., Ibrahim, J.G., Love, M.I. (2018) Heavy-tailed prior distributions for\n    sequence count data: removing the noise and preserving large differences.\n    Bioinformatics. https://doi.org/10.1093/bioinformatics/bty895\n\n\nCode\nlength(liver_enriched)\n\n\n[1] 788\n\n\n\n\nCode\ngo_enrich = gost(brain_enriched, organism = \"mmusculus\")\ngostplot(go_enrich, interactive = TRUE)\n\n\n\n\n\n\n\n\nCode\n# modify the g:Profiler data frame\ngp_mod = go_enrich$result[,c(\"query\", \"source\", \"term_id\",\n                                \"term_name\", \"p_value\", \"query_size\", \n                                \"intersection_size\", \"term_size\", \n                                \"effective_domain_size\")]\ngp_mod$GeneRatio = paste0(gp_mod$intersection_size,  \"/\", gp_mod$query_size)\ngp_mod$BgRatio = paste0(gp_mod$term_size, \"/\", gp_mod$effective_domain_size)\n\nnames(gp_mod) = c(\"Cluster\", \"Category\", \"ID\", \"Description\", \"p.adjust\", \n                    \"query_size\", \"Count\", \"term_size\", \"effective_domain_size\", \n                    \"GeneRatio\", \"BgRatio\")\n\nrow.names(gp_mod) = gp_mod$ID\n\n# define as enrichResult object\ngp_mod_enrich  = new(\"enrichResult\", result = gp_mod)\ngp_mod\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCluster\nCategory\nID\nDescription\np.adjust\nquery_size\nCount\nterm_size\neffective_domain_size\nGeneRatio\nBgRatio\n\n\n\n\nCORUM:141\nquery_1\nCORUM\nCORUM:141\nSos1-Abi1-Eps8 complex\n0.0499301\n14\n2\n3\n1082\n2/14\n3/1082\n\n\nCORUM:3143\nquery_1\nCORUM\nCORUM:3143\nSos1-Abi1-Eps8 complex\n0.0499301\n14\n2\n3\n1082\n2/14\n3/1082\n\n\nGO:0048856\nquery_1\nGO:BP\nGO:0048856\nanatomical structure development\n0.0000000\n190\n93\n6269\n26944\n93/190\n6269/26944\n\n\nGO:0032502\nquery_1\nGO:BP\nGO:0032502\ndevelopmental process\n0.0000000\n190\n96\n6854\n26944\n96/190\n6854/26944\n\n\nGO:0048513\nquery_1\nGO:BP\nGO:0048513\nanimal organ development\n0.0000000\n190\n61\n3260\n26944\n61/190\n3260/26944\n\n\nGO:0007275\nquery_1\nGO:BP\nGO:0007275\nmulticellular organism development\n0.0000000\n190\n77\n4879\n26944\n77/190\n4879/26944\n\n\nGO:0048731\nquery_1\nGO:BP\nGO:0048731\nsystem development\n0.0000000\n190\n69\n4117\n26944\n69/190\n4117/26944\n\n\nGO:0009653\nquery_1\nGO:BP\nGO:0009653\nanatomical structure morphogenesis\n0.0000000\n190\n53\n2761\n26944\n53/190\n2761/26944\n\n\nGO:0055085\nquery_1\nGO:BP\nGO:0055085\ntransmembrane transport\n0.0000000\n190\n38\n1525\n26944\n38/190\n1525/26944\n\n\nGO:0007399\nquery_1\nGO:BP\nGO:0007399\nnervous system development\n0.0000000\n190\n50\n2529\n26944\n50/190\n2529/26944\n\n\nGO:0009888\nquery_1\nGO:BP\nGO:0009888\ntissue development\n0.0000000\n190\n45\n2122\n26944\n45/190\n2122/26944\n\n\nGO:0023051\nquery_1\nGO:BP\nGO:0023051\nregulation of signaling\n0.0000004\n190\n59\n3616\n26944\n59/190\n3616/26944\n\n\nGO:0010646\nquery_1\nGO:BP\nGO:0010646\nregulation of cell communication\n0.0000004\n190\n59\n3616\n26944\n59/190\n3616/26944\n\n\nGO:0051239\nquery_1\nGO:BP\nGO:0051239\nregulation of multicellular organismal process\n0.0000006\n190\n54\n3165\n26944\n54/190\n3165/26944\n\n\nGO:0050793\nquery_1\nGO:BP\nGO:0050793\nregulation of developmental process\n0.0000006\n190\n49\n2698\n26944\n49/190\n2698/26944\n\n\nGO:0015711\nquery_1\nGO:BP\nGO:0015711\norganic anion transport\n0.0000016\n190\n19\n464\n26944\n19/190\n464/26944\n\n\nGO:0060322\nquery_1\nGO:BP\nGO:0060322\nhead development\n0.0000026\n190\n24\n778\n26944\n24/190\n778/26944\n\n\nGO:0046942\nquery_1\nGO:BP\nGO:0046942\ncarboxylic acid transport\n0.0000039\n190\n17\n384\n26944\n17/190\n384/26944\n\n\nGO:0015849\nquery_1\nGO:BP\nGO:0015849\norganic acid transport\n0.0000042\n190\n17\n386\n26944\n17/190\n386/26944\n\n\nGO:0060429\nquery_1\nGO:BP\nGO:0060429\nepithelium development\n0.0000053\n190\n31\n1309\n26944\n31/190\n1309/26944\n\n\nGO:0048522\nquery_1\nGO:BP\nGO:0048522\npositive regulation of cellular process\n0.0000059\n190\n79\n6078\n26944\n79/190\n6078/26944\n\n\nGO:0048583\nquery_1\nGO:BP\nGO:0048583\nregulation of response to stimulus\n0.0000062\n190\n60\n3987\n26944\n60/190\n3987/26944\n\n\nGO:0009966\nquery_1\nGO:BP\nGO:0009966\nregulation of signal transduction\n0.0000080\n190\n50\n3005\n26944\n50/190\n3005/26944\n\n\nGO:0000902\nquery_1\nGO:BP\nGO:0000902\ncell morphogenesis\n0.0000102\n190\n27\n1045\n26944\n27/190\n1045/26944\n\n\nGO:0022603\nquery_1\nGO:BP\nGO:0022603\nregulation of anatomical structure morphogenesis\n0.0000104\n190\n25\n904\n26944\n25/190\n904/26944\n\n\nGO:0051179\nquery_1\nGO:BP\nGO:0051179\nlocalization\n0.0000120\n190\n72\n5364\n26944\n72/190\n5364/26944\n\n\nGO:0072359\nquery_1\nGO:BP\nGO:0072359\ncirculatory system development\n0.0000157\n190\n29\n1216\n26944\n29/190\n1216/26944\n\n\nGO:0035239\nquery_1\nGO:BP\nGO:0035239\ntube morphogenesis\n0.0000171\n190\n25\n927\n26944\n25/190\n927/26944\n\n\nGO:0071702\nquery_1\nGO:BP\nGO:0071702\norganic substance transport\n0.0000195\n190\n43\n2419\n26944\n43/190\n2419/26944\n\n\nGO:0048518\nquery_1\nGO:BP\nGO:0048518\npositive regulation of biological process\n0.0000196\n190\n82\n6589\n26944\n82/190\n6589/26944\n\n\nGO:0007417\nquery_1\nGO:BP\nGO:0007417\ncentral nervous system development\n0.0000201\n190\n26\n1006\n26944\n26/190\n1006/26944\n\n\nGO:0022008\nquery_1\nGO:BP\nGO:0022008\nneurogenesis\n0.0000275\n190\n37\n1907\n26944\n37/190\n1907/26944\n\n\nGO:0065008\nquery_1\nGO:BP\nGO:0065008\nregulation of biological quality\n0.0000319\n190\n50\n3134\n26944\n50/190\n3134/26944\n\n\nGO:0035295\nquery_1\nGO:BP\nGO:0035295\ntube development\n0.0000330\n190\n28\n1181\n26944\n28/190\n1181/26944\n\n\nGO:0098739\nquery_1\nGO:BP\nGO:0098739\nimport across plasma membrane\n0.0000375\n190\n12\n201\n26944\n12/190\n201/26944\n\n\nGO:0006810\nquery_1\nGO:BP\nGO:0006810\ntransport\n0.0000380\n190\n62\n4397\n26944\n62/190\n4397/26944\n\n\nGO:0021543\nquery_1\nGO:BP\nGO:0021543\npallium development\n0.0000548\n190\n12\n208\n26944\n12/190\n208/26944\n\n\nGO:0032501\nquery_1\nGO:BP\nGO:0032501\nmulticellular organismal process\n0.0000598\n190\n101\n9132\n26944\n101/190\n9132/26944\n\n\nGO:0048667\nquery_1\nGO:BP\nGO:0048667\ncell morphogenesis involved in neuron differentiation\n0.0000640\n190\n20\n647\n26944\n20/190\n647/26944\n\n\nGO:2000026\nquery_1\nGO:BP\nGO:2000026\nregulation of multicellular organismal development\n0.0000737\n190\n32\n1550\n26944\n32/190\n1550/26944\n\n\nGO:0048858\nquery_1\nGO:BP\nGO:0048858\ncell projection morphogenesis\n0.0000786\n190\n21\n721\n26944\n21/190\n721/26944\n\n\nGO:0008283\nquery_1\nGO:BP\nGO:0008283\ncell population proliferation\n0.0000803\n190\n39\n2168\n26944\n39/190\n2168/26944\n\n\nGO:0007420\nquery_1\nGO:BP\nGO:0007420\nbrain development\n0.0000824\n190\n21\n723\n26944\n21/190\n723/26944\n\n\nGO:0048870\nquery_1\nGO:BP\nGO:0048870\ncell motility\n0.0001296\n190\n34\n1760\n26944\n34/190\n1760/26944\n\n\nGO:0034330\nquery_1\nGO:BP\nGO:0034330\ncell junction organization\n0.0001363\n190\n22\n814\n26944\n22/190\n814/26944\n\n\nGO:0032989\nquery_1\nGO:BP\nGO:0032989\ncellular anatomical entity morphogenesis\n0.0001684\n190\n22\n824\n26944\n22/190\n824/26944\n\n\nGO:0051234\nquery_1\nGO:BP\nGO:0051234\nestablishment of localization\n0.0001837\n190\n63\n4696\n26944\n63/190\n4696/26944\n\n\nGO:0016477\nquery_1\nGO:BP\nGO:0016477\ncell migration\n0.0002107\n190\n31\n1538\n26944\n31/190\n1538/26944\n\n\nGO:0042127\nquery_1\nGO:BP\nGO:0042127\nregulation of cell population proliferation\n0.0002180\n190\n34\n1799\n26944\n34/190\n1799/26944\n\n\nGO:0048812\nquery_1\nGO:BP\nGO:0048812\nneuron projection morphogenesis\n0.0002235\n190\n20\n699\n26944\n20/190\n699/26944\n\n\nGO:0120039\nquery_1\nGO:BP\nGO:0120039\nplasma membrane bounded cell projection morphogenesis\n0.0003136\n190\n20\n714\n26944\n20/190\n714/26944\n\n\nGO:0006869\nquery_1\nGO:BP\nGO:0006869\nlipid transport\n0.0003207\n190\n16\n459\n26944\n16/190\n459/26944\n\n\nGO:0006811\nquery_1\nGO:BP\nGO:0006811\nmonoatomic ion transport\n0.0003327\n190\n27\n1239\n26944\n27/190\n1239/26944\n\n\nGO:0042592\nquery_1\nGO:BP\nGO:0042592\nhomeostatic process\n0.0003471\n190\n34\n1835\n26944\n34/190\n1835/26944\n\n\nGO:1905039\nquery_1\nGO:BP\nGO:1905039\ncarboxylic acid transmembrane transport\n0.0003553\n190\n10\n159\n26944\n10/190\n159/26944\n\n\nGO:1903825\nquery_1\nGO:BP\nGO:1903825\norganic acid transmembrane transport\n0.0003767\n190\n10\n160\n26944\n10/190\n160/26944\n\n\nGO:0021537\nquery_1\nGO:BP\nGO:0021537\ntelencephalon development\n0.0005154\n190\n13\n306\n26944\n13/190\n306/26944\n\n\nGO:0050808\nquery_1\nGO:BP\nGO:0050808\nsynapse organization\n0.0005369\n190\n17\n539\n26944\n17/190\n539/26944\n\n\nGO:0009967\nquery_1\nGO:BP\nGO:0009967\npositive regulation of signal transduction\n0.0005963\n190\n31\n1613\n26944\n31/190\n1613/26944\n\n\nGO:0031175\nquery_1\nGO:BP\nGO:0031175\nneuron projection development\n0.0007619\n190\n25\n1131\n26944\n25/190\n1131/26944\n\n\nGO:0010647\nquery_1\nGO:BP\nGO:0010647\npositive regulation of cell communication\n0.0007666\n190\n35\n1990\n26944\n35/190\n1990/26944\n\n\nGO:0023056\nquery_1\nGO:BP\nGO:0023056\npositive regulation of signaling\n0.0007666\n190\n35\n1990\n26944\n35/190\n1990/26944\n\n\nGO:0000165\nquery_1\nGO:BP\nGO:0000165\nMAPK cascade\n0.0008051\n190\n20\n758\n26944\n20/190\n758/26944\n\n\nGO:0042908\nquery_1\nGO:BP\nGO:0042908\nxenobiotic transport\n0.0008319\n190\n6\n42\n26944\n6/190\n42/26944\n\n\nGO:0007166\nquery_1\nGO:BP\nGO:0007166\ncell surface receptor signaling pathway\n0.0008615\n190\n43\n2766\n26944\n43/190\n2766/26944\n\n\nGO:0007267\nquery_1\nGO:BP\nGO:0007267\ncell-cell signaling\n0.0009186\n190\n32\n1734\n26944\n32/190\n1734/26944\n\n\nGO:0048871\nquery_1\nGO:BP\nGO:0048871\nmulticellular organismal-level homeostasis\n0.0009436\n190\n22\n912\n26944\n22/190\n912/26944\n\n\nGO:0060249\nquery_1\nGO:BP\nGO:0060249\nanatomical structure homeostasis\n0.0009622\n190\n12\n271\n26944\n12/190\n271/26944\n\n\nGO:0001894\nquery_1\nGO:BP\nGO:0001894\ntissue homeostasis\n0.0009622\n190\n12\n271\n26944\n12/190\n271/26944\n\n\nGO:0021766\nquery_1\nGO:BP\nGO:0021766\nhippocampus development\n0.0016338\n190\n8\n107\n26944\n8/190\n107/26944\n\n\nGO:0010876\nquery_1\nGO:BP\nGO:0010876\nlipid localization\n0.0016348\n190\n16\n519\n26944\n16/190\n519/26944\n\n\nGO:0030154\nquery_1\nGO:BP\nGO:0030154\ncell differentiation\n0.0018528\n190\n61\n4777\n26944\n61/190\n4777/26944\n\n\nGO:0048869\nquery_1\nGO:BP\nGO:0048869\ncellular developmental process\n0.0018662\n190\n61\n4778\n26944\n61/190\n4778/26944\n\n\nGO:0015801\nquery_1\nGO:BP\nGO:0015801\naromatic amino acid transport\n0.0019562\n190\n4\n12\n26944\n4/190\n12/26944\n\n\nGO:0002009\nquery_1\nGO:BP\nGO:0002009\nmorphogenesis of an epithelium\n0.0024855\n190\n16\n536\n26944\n16/190\n536/26944\n\n\nGO:0048468\nquery_1\nGO:BP\nGO:0048468\ncell development\n0.0028680\n190\n46\n3202\n26944\n46/190\n3202/26944\n\n\nGO:0048699\nquery_1\nGO:BP\nGO:0048699\ngeneration of neurons\n0.0030070\n190\n30\n1651\n26944\n30/190\n1651/26944\n\n\nGO:0048646\nquery_1\nGO:BP\nGO:0048646\nanatomical structure formation involved in morphogenesis\n0.0030499\n190\n25\n1221\n26944\n25/190\n1221/26944\n\n\nGO:0051094\nquery_1\nGO:BP\nGO:0051094\npositive regulation of developmental process\n0.0032213\n190\n28\n1480\n26944\n28/190\n1480/26944\n\n\nGO:0061564\nquery_1\nGO:BP\nGO:0061564\naxon development\n0.0033074\n190\n16\n548\n26944\n16/190\n548/26944\n\n\nGO:0001568\nquery_1\nGO:BP\nGO:0001568\nblood vessel development\n0.0035696\n190\n19\n761\n26944\n19/190\n761/26944\n\n\nGO:0089718\nquery_1\nGO:BP\nGO:0089718\namino acid import across plasma membrane\n0.0038184\n190\n6\n54\n26944\n6/190\n54/26944\n\n\nGO:0048519\nquery_1\nGO:BP\nGO:0048519\nnegative regulation of biological process\n0.0047935\n190\n70\n5966\n26944\n70/190\n5966/26944\n\n\nGO:0048589\nquery_1\nGO:BP\nGO:0048589\ndevelopmental growth\n0.0055980\n190\n19\n785\n26944\n19/190\n785/26944\n\n\nGO:0030030\nquery_1\nGO:BP\nGO:0030030\ncell projection organization\n0.0058156\n190\n30\n1706\n26944\n30/190\n1706/26944\n\n\nGO:0089709\nquery_1\nGO:BP\nGO:0089709\nL-histidine transmembrane transport\n0.0058894\n190\n3\n5\n26944\n3/190\n5/26944\n\n\nGO:0006812\nquery_1\nGO:BP\nGO:0006812\nmonoatomic cation transport\n0.0060700\n190\n22\n1022\n26944\n22/190\n1022/26944\n\n\nGO:0051240\nquery_1\nGO:BP\nGO:0051240\npositive regulation of multicellular organismal process\n0.0062556\n190\n31\n1804\n26944\n31/190\n1804/26944\n\n\nGO:0001944\nquery_1\nGO:BP\nGO:0001944\nvasculature development\n0.0064772\n190\n19\n793\n26944\n19/190\n793/26944\n\n\nGO:0030900\nquery_1\nGO:BP\nGO:0030900\nforebrain development\n0.0066686\n190\n14\n447\n26944\n14/190\n447/26944\n\n\nGO:0007423\nquery_1\nGO:BP\nGO:0007423\nsensory organ development\n0.0068559\n190\n17\n650\n26944\n17/190\n650/26944\n\n\nGO:0048729\nquery_1\nGO:BP\nGO:0048729\ntissue morphogenesis\n0.0069967\n190\n17\n651\n26944\n17/190\n651/26944\n\n\nGO:1902531\nquery_1\nGO:BP\nGO:1902531\nregulation of intracellular signal transduction\n0.0070027\n190\n30\n1722\n26944\n30/190\n1722/26944\n\n\nGO:0048666\nquery_1\nGO:BP\nGO:0048666\nneuron development\n0.0077082\n190\n25\n1287\n26944\n25/190\n1287/26944\n\n\nGO:0048514\nquery_1\nGO:BP\nGO:0048514\nblood vessel morphogenesis\n0.0078977\n190\n17\n657\n26944\n17/190\n657/26944\n\n\nGO:0007155\nquery_1\nGO:BP\nGO:0007155\ncell adhesion\n0.0081522\n190\n27\n1465\n26944\n27/190\n1465/26944\n\n\nGO:0030001\nquery_1\nGO:BP\nGO:0030001\nmetal ion transport\n0.0083653\n190\n20\n884\n26944\n20/190\n884/26944\n\n\nGO:0021761\nquery_1\nGO:BP\nGO:0021761\nlimbic system development\n0.0099147\n190\n8\n136\n26944\n8/190\n136/26944\n\n\nGO:0043408\nquery_1\nGO:BP\nGO:0043408\nregulation of MAPK cascade\n0.0102169\n190\n17\n670\n26944\n17/190\n670/26944\n\n\nGO:0120036\nquery_1\nGO:BP\nGO:0120036\nplasma membrane bounded cell projection organization\n0.0105280\n190\n29\n1666\n26944\n29/190\n1666/26944\n\n\nGO:0006915\nquery_1\nGO:BP\nGO:0006915\napoptotic process\n0.0116163\n190\n33\n2050\n26944\n33/190\n2050/26944\n\n\nGO:0032328\nquery_1\nGO:BP\nGO:0032328\nalanine transport\n0.0116984\n190\n4\n18\n26944\n4/190\n18/26944\n\n\nGO:0070887\nquery_1\nGO:BP\nGO:0070887\ncellular response to chemical stimulus\n0.0118233\n190\n44\n3162\n26944\n44/190\n3162/26944\n\n\nGO:0048584\nquery_1\nGO:BP\nGO:0048584\npositive regulation of response to stimulus\n0.0136077\n190\n36\n2359\n26944\n36/190\n2359/26944\n\n\nGO:0008610\nquery_1\nGO:BP\nGO:0008610\nlipid biosynthetic process\n0.0139009\n190\n17\n686\n26944\n17/190\n686/26944\n\n\nGO:0150104\nquery_1\nGO:BP\nGO:0150104\ntransport across blood-brain barrier\n0.0147363\n190\n4\n19\n26944\n4/190\n19/26944\n\n\nGO:0035633\nquery_1\nGO:BP\nGO:0035633\nmaintenance of blood-brain barrier\n0.0147363\n190\n4\n19\n26944\n4/190\n19/26944\n\n\nGO:0060856\nquery_1\nGO:BP\nGO:0060856\nestablishment of blood-brain barrier\n0.0147363\n190\n4\n19\n26944\n4/190\n19/26944\n\n\nGO:0007409\nquery_1\nGO:BP\nGO:0007409\naxonogenesis\n0.0153363\n190\n14\n481\n26944\n14/190\n481/26944\n\n\nGO:0141124\nquery_1\nGO:BP\nGO:0141124\nintracellular signaling cassette\n0.0156398\n190\n30\n1794\n26944\n30/190\n1794/26944\n\n\nGO:0065007\nquery_1\nGO:BP\nGO:0065007\nbiological regulation\n0.0166254\n190\n125\n13527\n26944\n125/190\n13527/26944\n\n\nGO:0050803\nquery_1\nGO:BP\nGO:0050803\nregulation of synapse structure or activity\n0.0169054\n190\n11\n299\n26944\n11/190\n299/26944\n\n\nGO:0010232\nquery_1\nGO:BP\nGO:0010232\nvascular transport\n0.0183190\n190\n4\n20\n26944\n4/190\n20/26944\n\n\nGO:0060562\nquery_1\nGO:BP\nGO:0060562\nepithelial tube morphogenesis\n0.0195003\n190\n12\n363\n26944\n12/190\n363/26944\n\n\nGO:0048523\nquery_1\nGO:BP\nGO:0048523\nnegative regulation of cellular process\n0.0195045\n190\n65\n5599\n26944\n65/190\n5599/26944\n\n\nGO:0015718\nquery_1\nGO:BP\nGO:0015718\nmonocarboxylic acid transport\n0.0201524\n190\n9\n197\n26944\n9/190\n197/26944\n\n\nGO:0051960\nquery_1\nGO:BP\nGO:0051960\nregulation of nervous system development\n0.0203891\n190\n15\n562\n26944\n15/190\n562/26944\n\n\nGO:0099173\nquery_1\nGO:BP\nGO:0099173\npostsynapse organization\n0.0210129\n190\n10\n250\n26944\n10/190\n250/26944\n\n\nGO:0007154\nquery_1\nGO:BP\nGO:0007154\ncell communication\n0.0214224\n190\n81\n7582\n26944\n81/190\n7582/26944\n\n\nGO:0030111\nquery_1\nGO:BP\nGO:0030111\nregulation of Wnt signaling pathway\n0.0229832\n190\n11\n309\n26944\n11/190\n309/26944\n\n\nGO:0012501\nquery_1\nGO:BP\nGO:0012501\nprogrammed cell death\n0.0244176\n190\n33\n2125\n26944\n33/190\n2125/26944\n\n\nGO:0008219\nquery_1\nGO:BP\nGO:0008219\ncell death\n0.0244176\n190\n33\n2125\n26944\n33/190\n2125/26944\n\n\nGO:0098655\nquery_1\nGO:BP\nGO:0098655\nmonoatomic cation transmembrane transport\n0.0261546\n190\n18\n797\n26944\n18/190\n797/26944\n\n\nGO:0051897\nquery_1\nGO:BP\nGO:0051897\npositive regulation of phosphatidylinositol 3-kinase/protein kinase B signal transduction\n0.0266247\n190\n9\n204\n26944\n9/190\n204/26944\n\n\nGO:0048598\nquery_1\nGO:BP\nGO:0048598\nembryonic morphogenesis\n0.0270955\n190\n16\n648\n26944\n16/190\n648/26944\n\n\nGO:0030182\nquery_1\nGO:BP\nGO:0030182\nneuron differentiation\n0.0280434\n190\n27\n1569\n26944\n27/190\n1569/26944\n\n\nGO:0007507\nquery_1\nGO:BP\nGO:0007507\nheart development\n0.0297592\n190\n16\n653\n26944\n16/190\n653/26944\n\n\nGO:0045595\nquery_1\nGO:BP\nGO:0045595\nregulation of cell differentiation\n0.0299455\n190\n29\n1761\n26944\n29/190\n1761/26944\n\n\nGO:0006793\nquery_1\nGO:BP\nGO:0006793\nphosphorus metabolic process\n0.0310990\n190\n36\n2450\n26944\n36/190\n2450/26944\n\n\nGO:0030178\nquery_1\nGO:BP\nGO:0030178\nnegative regulation of Wnt signaling pathway\n0.0325425\n190\n8\n160\n26944\n8/190\n160/26944\n\n\nGO:0042886\nquery_1\nGO:BP\nGO:0042886\namide transport\n0.0349152\n190\n12\n385\n26944\n12/190\n385/26944\n\n\nGO:0033036\nquery_1\nGO:BP\nGO:0033036\nmacromolecule localization\n0.0363057\n190\n42\n3092\n26944\n42/190\n3092/26944\n\n\nGO:0050789\nquery_1\nGO:BP\nGO:0050789\nregulation of biological process\n0.0406072\n190\n121\n13144\n26944\n121/190\n13144/26944\n\n\nGO:0120035\nquery_1\nGO:BP\nGO:0120035\nregulation of plasma membrane bounded cell projection organization\n0.0442460\n190\n17\n751\n26944\n17/190\n751/26944\n\n\nGO:0043067\nquery_1\nGO:BP\nGO:0043067\nregulation of programmed cell death\n0.0456833\n190\n28\n1707\n26944\n28/190\n1707/26944\n\n\nGO:0098657\nquery_1\nGO:BP\nGO:0098657\nimport into cell\n0.0485926\n190\n19\n916\n26944\n19/190\n916/26944\n\n\nGO:0071944\nquery_1\nGO:CC\nGO:0071944\ncell periphery\n0.0000000\n194\n100\n6862\n26995\n100/194\n6862/26995\n\n\nGO:0098590\nquery_1\nGO:CC\nGO:0098590\nplasma membrane region\n0.0000000\n194\n41\n1408\n26995\n41/194\n1408/26995\n\n\nGO:0016324\nquery_1\nGO:CC\nGO:0016324\napical plasma membrane\n0.0000000\n194\n23\n461\n26995\n23/194\n461/26995\n\n\nGO:0016020\nquery_1\nGO:CC\nGO:0016020\nmembrane\n0.0000000\n194\n122\n10191\n26995\n122/194\n10191/26995\n\n\nGO:0005886\nquery_1\nGO:CC\nGO:0005886\nplasma membrane\n0.0000000\n194\n89\n6367\n26995\n89/194\n6367/26995\n\n\nGO:0045177\nquery_1\nGO:CC\nGO:0045177\napical part of cell\n0.0000000\n194\n23\n562\n26995\n23/194\n562/26995\n\n\nGO:0009925\nquery_1\nGO:CC\nGO:0009925\nbasal plasma membrane\n0.0000029\n194\n15\n312\n26995\n15/194\n312/26995\n\n\nGO:0045178\nquery_1\nGO:CC\nGO:0045178\nbasal part of cell\n0.0000064\n194\n15\n331\n26995\n15/194\n331/26995\n\n\nGO:0016323\nquery_1\nGO:CC\nGO:0016323\nbasolateral plasma membrane\n0.0000355\n194\n13\n275\n26995\n13/194\n275/26995\n\n\nGO:0030054\nquery_1\nGO:CC\nGO:0030054\ncell junction\n0.0000762\n194\n39\n2260\n26995\n39/194\n2260/26995\n\n\nGO:0120025\nquery_1\nGO:CC\nGO:0120025\nplasma membrane bounded cell projection\n0.0002408\n194\n40\n2460\n26995\n40/194\n2460/26995\n\n\nGO:0042995\nquery_1\nGO:CC\nGO:0042995\ncell projection\n0.0002613\n194\n41\n2564\n26995\n41/194\n2564/26995\n\n\nGO:0031012\nquery_1\nGO:CC\nGO:0031012\nextracellular matrix\n0.0011717\n194\n15\n499\n26995\n15/194\n499/26995\n\n\nGO:0030312\nquery_1\nGO:CC\nGO:0030312\nexternal encapsulating structure\n0.0012297\n194\n15\n501\n26995\n15/194\n501/26995\n\n\nGO:0043005\nquery_1\nGO:CC\nGO:0043005\nneuron projection\n0.0015662\n194\n28\n1525\n26995\n28/194\n1525/26995\n\n\nGO:0036477\nquery_1\nGO:CC\nGO:0036477\nsomatodendritic compartment\n0.0015798\n194\n23\n1103\n26995\n23/194\n1103/26995\n\n\nGO:0070161\nquery_1\nGO:CC\nGO:0070161\nanchoring junction\n0.0019243\n194\n18\n729\n26995\n18/194\n729/26995\n\n\nGO:0005576\nquery_1\nGO:CC\nGO:0005576\nextracellular region\n0.0038707\n194\n38\n2554\n26995\n38/194\n2554/26995\n\n\nGO:0009986\nquery_1\nGO:CC\nGO:0009986\ncell surface\n0.0064805\n194\n21\n1037\n26995\n21/194\n1037/26995\n\n\nGO:0110165\nquery_1\nGO:CC\nGO:0110165\ncellular anatomical entity\n0.0079523\n194\n182\n22653\n26995\n182/194\n22653/26995\n\n\nGO:0016327\nquery_1\nGO:CC\nGO:0016327\napicolateral plasma membrane\n0.0129450\n194\n4\n27\n26995\n4/194\n27/26995\n\n\nGO:0045202\nquery_1\nGO:CC\nGO:0045202\nsynapse\n0.0161906\n194\n27\n1641\n26995\n27/194\n1641/26995\n\n\nGO:0030425\nquery_1\nGO:CC\nGO:0030425\ndendrite\n0.0178150\n194\n17\n783\n26995\n17/194\n783/26995\n\n\nGO:0097447\nquery_1\nGO:CC\nGO:0097447\ndendritic tree\n0.0183813\n194\n17\n785\n26995\n17/194\n785/26995\n\n\nGO:0030424\nquery_1\nGO:CC\nGO:0030424\naxon\n0.0235164\n194\n17\n801\n26995\n17/194\n801/26995\n\n\nGO:0015629\nquery_1\nGO:CC\nGO:0015629\nactin cytoskeleton\n0.0250212\n194\n13\n503\n26995\n13/194\n503/26995\n\n\nGO:0062023\nquery_1\nGO:CC\nGO:0062023\ncollagen-containing extracellular matrix\n0.0271177\n194\n11\n371\n26995\n11/194\n371/26995\n\n\nGO:0043025\nquery_1\nGO:CC\nGO:0043025\nneuronal cell body\n0.0325979\n194\n16\n743\n26995\n16/194\n743/26995\n\n\nGO:0005215\nquery_1\nGO:MF\nGO:0005215\ntransporter activity\n0.0000000\n190\n35\n1189\n25063\n35/190\n1189/25063\n\n\nGO:0008514\nquery_1\nGO:MF\nGO:0008514\norganic anion transmembrane transporter activity\n0.0000000\n190\n17\n264\n25063\n17/190\n264/25063\n\n\nGO:0022857\nquery_1\nGO:MF\nGO:0022857\ntransmembrane transporter activity\n0.0000001\n190\n31\n1087\n25063\n31/190\n1087/25063\n\n\nGO:0022804\nquery_1\nGO:MF\nGO:0022804\nactive transmembrane transporter activity\n0.0000007\n190\n19\n435\n25063\n19/190\n435/25063\n\n\nGO:0046943\nquery_1\nGO:MF\nGO:0046943\ncarboxylic acid transmembrane transporter activity\n0.0000017\n190\n13\n189\n25063\n13/190\n189/25063\n\n\nGO:0005342\nquery_1\nGO:MF\nGO:0005342\norganic acid transmembrane transporter activity\n0.0000018\n190\n13\n190\n25063\n13/190\n190/25063\n\n\nGO:0005319\nquery_1\nGO:MF\nGO:0005319\nlipid transporter activity\n0.0000096\n190\n12\n179\n25063\n12/190\n179/25063\n\n\nGO:0015291\nquery_1\nGO:MF\nGO:0015291\nsecondary active transmembrane transporter activity\n0.0000377\n190\n14\n290\n25063\n14/190\n290/25063\n\n\nGO:0005515\nquery_1\nGO:MF\nGO:0005515\nprotein binding\n0.0000424\n190\n116\n10460\n25063\n116/190\n10460/25063\n\n\nGO:0042910\nquery_1\nGO:MF\nGO:0042910\nxenobiotic transmembrane transporter activity\n0.0002910\n190\n6\n38\n25063\n6/190\n38/25063\n\n\nGO:0015173\nquery_1\nGO:MF\nGO:0015173\naromatic amino acid transmembrane transporter activity\n0.0004768\n190\n4\n10\n25063\n4/190\n10/25063\n\n\nGO:0008028\nquery_1\nGO:MF\nGO:0008028\nmonocarboxylic acid transmembrane transporter activity\n0.0006871\n190\n7\n69\n25063\n7/190\n69/25063\n\n\nGO:0005290\nquery_1\nGO:MF\nGO:0005290\nL-histidine transmembrane transporter activity\n0.0012543\n190\n3\n4\n25063\n3/190\n4/25063\n\n\nGO:0140333\nquery_1\nGO:MF\nGO:0140333\nglycerophospholipid flippase activity\n0.0022194\n190\n4\n14\n25063\n4/190\n14/25063\n\n\nGO:0140327\nquery_1\nGO:MF\nGO:0140327\nflippase activity\n0.0051837\n190\n4\n17\n25063\n4/190\n17/25063\n\n\nGO:0001540\nquery_1\nGO:MF\nGO:0001540\namyloid-beta binding\n0.0080306\n190\n6\n66\n25063\n6/190\n66/25063\n\n\nGO:0050839\nquery_1\nGO:MF\nGO:0050839\ncell adhesion molecule binding\n0.0112496\n190\n11\n292\n25063\n11/190\n292/25063\n\n\nGO:0015175\nquery_1\nGO:MF\nGO:0015175\nneutral L-amino acid transmembrane transporter activity\n0.0118318\n190\n5\n42\n25063\n5/190\n42/25063\n\n\nGO:0015318\nquery_1\nGO:MF\nGO:0015318\ninorganic molecular entity transmembrane transporter activity\n0.0323750\n190\n16\n657\n25063\n16/190\n657/25063\n\n\nGO:1901618\nquery_1\nGO:MF\nGO:1901618\norganic hydroxy compound transmembrane transporter activity\n0.0373100\n190\n5\n53\n25063\n5/190\n53/25063\n\n\nGO:0140326\nquery_1\nGO:MF\nGO:0140326\nATPase-coupled intramembrane lipid transporter activity\n0.0417784\n190\n4\n28\n25063\n4/190\n28/25063\n\n\nGO:0140830\nquery_1\nGO:MF\nGO:0140830\nL-glutamine, sodium:proton antiporter activity\n0.0420366\n190\n2\n2\n25063\n2/190\n2/25063\n\n\nGO:0017147\nquery_1\nGO:MF\nGO:0017147\nWnt-protein binding\n0.0481766\n190\n4\n29\n25063\n4/190\n29/25063\n\n\nKEGG:05200\nquery_1\nKEGG\nKEGG:05200\nPathways in cancer\n0.0348500\n86\n14\n543\n9330\n14/86\n543/9330\n\n\nKEGG:05226\nquery_1\nKEGG\nKEGG:05226\nGastric cancer\n0.0387416\n86\n7\n150\n9330\n7/86\n150/9330\n\n\nREAC:R-MMU-382551\nquery_1\nREAC\nREAC:R-MMU-382551\nTransport of small molecules\n0.0000003\n84\n25\n628\n8405\n25/84\n628/8405\n\n\nREAC:R-MMU-425407\nquery_1\nREAC\nREAC:R-MMU-425407\nSLC-mediated transmembrane transport\n0.0000005\n84\n15\n207\n8405\n15/84\n207/8405\n\n\nREAC:R-MMU-352230\nquery_1\nREAC\nREAC:R-MMU-352230\nAmino acid transport across the plasma membrane\n0.0027347\n84\n5\n29\n8405\n5/84\n29/8405\n\n\nREAC:R-MMU-425393\nquery_1\nREAC\nREAC:R-MMU-425393\nTransport of inorganic cations/anions and amino acids/oligopeptides\n0.0115187\n84\n7\n93\n8405\n7/84\n93/8405\n\n\nREAC:R-MMU-556833\nquery_1\nREAC\nREAC:R-MMU-556833\nMetabolism of lipids\n0.0430149\n84\n16\n570\n8405\n16/84\n570/8405\n\n\nTF:M07289\nquery_1\nTF\nTF:M07289\nFactor: GKLF; motif: NNNRGGNGNGGSN\n0.0000028\n191\n169\n15234\n21629\n169/191\n15234/21629\n\n\nTF:M10375\nquery_1\nTF\nTF:M10375\nFactor: Sp1; motif: GGNGGGGGNGGGGGMGGGGCNGGG\n0.0000176\n191\n133\n10720\n21629\n133/191\n10720/21629\n\n\nTF:M10276_1\nquery_1\nTF\nTF:M10276_1\nFactor: Kaiso; motif: SARNYCTCGCGAGAN; match class: 1\n0.0000706\n191\n125\n9977\n21629\n125/191\n9977/21629\n\n\nTF:M02933\nquery_1\nTF\nTF:M02933\nFactor: ZF5; motif: GYCGCGCARNGCNN\n0.0001358\n191\n120\n9499\n21629\n120/191\n9499/21629\n\n\nTF:M02023\nquery_1\nTF\nTF:M02023\nFactor: MAZ; motif: NKGGGAGGGGRGGR\n0.0002606\n191\n105\n7941\n21629\n105/191\n7941/21629\n\n\nTF:M02933_1\nquery_1\nTF\nTF:M02933_1\nFactor: ZF5; motif: GYCGCGCARNGCNN; match class: 1\n0.0003833\n191\n84\n5832\n21629\n84/191\n5832/21629\n\n\nTF:M07289_1\nquery_1\nTF\nTF:M07289_1\nFactor: GKLF; motif: NNNRGGNGNGGSN; match class: 1\n0.0007775\n191\n130\n10917\n21629\n130/191\n10917/21629\n\n\nTF:M00333\nquery_1\nTF\nTF:M00333\nFactor: ZF5; motif: NRNGNGCGCGCWN\n0.0013384\n191\n157\n14398\n21629\n157/191\n14398/21629\n\n\nTF:M00333_1\nquery_1\nTF\nTF:M00333_1\nFactor: ZF5; motif: NRNGNGCGCGCWN; match class: 1\n0.0019685\n191\n131\n11183\n21629\n131/191\n11183/21629\n\n\nTF:M10209\nquery_1\nTF\nTF:M10209\nFactor: E2F-1; motif: GNGGGCGGGRMN\n0.0022123\n191\n155\n14210\n21629\n155/191\n14210/21629\n\n\nTF:M00716\nquery_1\nTF\nTF:M00716\nFactor: ZF5; motif: GSGCGCGR\n0.0035464\n191\n159\n14823\n21629\n159/191\n14823/21629\n\n\nTF:M07436\nquery_1\nTF\nTF:M07436\nFactor: WT1; motif: NNGGGNGGGSGN\n0.0037644\n191\n99\n7691\n21629\n99/191\n7691/21629\n\n\nTF:M07326_1\nquery_1\nTF\nTF:M07326_1\nFactor: Mef-2A; motif: GNNYTAAAWATAR; match class: 1\n0.0038961\n191\n5\n26\n21629\n5/191\n26/21629\n\n\nTF:M02023_1\nquery_1\nTF\nTF:M02023_1\nFactor: MAZ; motif: NKGGGAGGGGRGGR; match class: 1\n0.0045374\n191\n63\n4130\n21629\n63/191\n4130/21629\n\n\nTF:M10209_1\nquery_1\nTF\nTF:M10209_1\nFactor: E2F-1; motif: GNGGGCGGGRMN; match class: 1\n0.0045908\n191\n125\n10616\n21629\n125/191\n10616/21629\n\n\nTF:M00803\nquery_1\nTF\nTF:M00803\nFactor: E2F; motif: GGCGSG\n0.0054322\n191\n123\n10412\n21629\n123/191\n10412/21629\n\n\nTF:M01118\nquery_1\nTF\nTF:M01118\nFactor: WT1; motif: SMCNCCNSC\n0.0055003\n191\n102\n8071\n21629\n102/191\n8071/21629\n\n\nTF:M00803_1\nquery_1\nTF\nTF:M00803_1\nFactor: E2F; motif: GGCGSG; match class: 1\n0.0062111\n191\n92\n7031\n21629\n92/191\n7031/21629\n\n\nTF:M07040\nquery_1\nTF\nTF:M07040\nFactor: GKLF; motif: NNRRGRRNGNSNNN\n0.0085054\n191\n143\n12890\n21629\n143/191\n12890/21629\n\n\nTF:M01104\nquery_1\nTF\nTF:M01104\nFactor: MOVO-B; motif: GNGGGGG\n0.0102348\n191\n97\n7635\n21629\n97/191\n7635/21629\n\n\nTF:M10276\nquery_1\nTF\nTF:M10276\nFactor: Kaiso; motif: SARNYCTCGCGAGAN\n0.0131366\n191\n147\n13469\n21629\n147/191\n13469/21629\n\n\nTF:M02742\nquery_1\nTF\nTF:M02742\nFactor: E2F-2; motif: NNNANGGCGCGCNNN\n0.0136810\n191\n55\n3530\n21629\n55/191\n3530/21629\n\n\nTF:M01240\nquery_1\nTF\nTF:M01240\nFactor: BEN; motif: CAGCGRNV\n0.0174652\n191\n167\n16194\n21629\n167/191\n16194/21629\n\n\nTF:M00716_1\nquery_1\nTF\nTF:M00716_1\nFactor: ZF5; motif: GSGCGCGR; match class: 1\n0.0185489\n191\n135\n12044\n21629\n135/191\n12044/21629\n\n\nTF:M10375_1\nquery_1\nTF\nTF:M10375_1\nFactor: Sp1; motif: GGNGGGGGNGGGGGMGGGGCNGGG; match class: 1\n0.0280992\n191\n93\n7376\n21629\n93/191\n7376/21629\n\n\nTF:M00665\nquery_1\nTF\nTF:M00665\nFactor: Sp3; motif: ASMCTTGGGSRGGG\n0.0389990\n191\n91\n7220\n21629\n91/191\n7220/21629\n\n\nTF:M02089\nquery_1\nTF\nTF:M02089\nFactor: E2F-3; motif: GGCGGGN\n0.0477466\n191\n127\n11263\n21629\n127/191\n11263/21629\n\n\nWP:WP4344\nquery_1\nWP\nWP:WP4344\nSphingolipid metabolism overview\n0.0060915\n52\n4\n24\n4496\n4/52\n24/4496\n\n\nWP:WP5298\nquery_1\nWP\nWP:WP5298\nDravet syndrome Scn1a A1783V point mutation model\n0.0066423\n52\n6\n72\n4496\n6/52\n72/4496\n\n\nWP:WP4690\nquery_1\nWP\nWP:WP4690\nSphingolipid metabolism integrated pathway\n0.0071900\n52\n4\n25\n4496\n4/52\n25/4496\n\n\n\n\n\n\nCode\nbarplot(gp_mod_enrich, showCategory = 40, font.size = 16) + \n  ggplot2::facet_grid(~Cluster) +\n  ggplot2::ylab(\"Intersection size\")"
  },
  {
    "objectID": "02-magma.html",
    "href": "02-magma.html",
    "title": "Disease risk gene enrichment anlaysis via MAGMA",
    "section": "",
    "text": "So the idea of using a tool like MAGMA is to try and see if we observe enrichment for risk genes in particular groups. The common example is to look at celltypes with single cell seq data. Perhaps you’ve heard microglia come up a lot in AD as a major celltype of interest? A lot of that interest came about when we realised microglia are very enriched for the risk genes in AD, suggesting they play an important role in the disease.\nThis type of approach relies on having decent GWAS data for your condition of interest so we know what risk genes exist. This means it’s important to be aware of the quality of the GWAS you’re using, as there are many GWAS studies that aren’t particularly well powered for example. The majority of GWAS studies are also done in largely white populations of European decent, so there’s also a lack of representation of most of the worlds genetic diversity.\nIn dementia, there’s also the issue of unreliable diagnosis within GWAS. Some proportion of cases are probably mislabelled, for instance someone diagnosed with one type of dementia who actually has a different type, or someone who does have the disease they are diagnosed with, but also have additional dementia (like vascular dementia, the most common secondary dementia), either of which muddies the water of any GWAS data. Additionally there’s the controversy around the use of proxy cases, where dementia status is inferred based on familiy history (often self-reported family history too…), so you may see analysis done with and without proxy cases included in the GWAS summary stats.\nLastly, AD in particular is a funny case in that APOE is the biggest risk gene by a huge margin, so it can sometimes cover up the effect of smaller genes. So you may see folk doing analysis with and without APOE included in the summary stats for AD in the literature.\n\n\n\n\nCode\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggthemes)\nlibrary(tximport)\nlibrary(pheatmap)\nlibrary(tibble)\nlibrary(purrr)\nlibrary(readr)\nlibrary(here)\nlibrary(stringr)\nlibrary(gt)\nlibrary(ComplexHeatmap)\n\n\n\n\n\nSo in our case we’re interested in the .gsa.out files MAGMA has produced as these contain the stats for if our gene lists were significantly enriched for our risk genes. A fun complication is the our schizophrenia and white matter hyperintensities outputs have a 4 line header to skip when reading the file in, whereas all the others have a 3 line header.\nAlso note that I process the ppi module lists here as well. What do you think the advantage of adding that data here for analysis is? Why not just copy all this code to a new file or just add it to the rest of the PPI code and just change the input data?\nAdd your thoughts below:\n\n\nCode\n# List files\nfiles &lt;- list.files(here::here(\"data/magma/results\"), \n                    pattern = \"*.gsa.out\", full.names = TRUE)\nfiles_ppi &lt;- list.files(here::here(\"data/ppi/magma_results\"), \n                    pattern = \"*.gsa.out\", full.names = TRUE)\nfiles &lt;- c(files, files_ppi)\n# separate scz files\nfiles_scz &lt;- files[grepl(\"_scz|_wmh_\", files)]\nfiles_no_scz &lt;- files[!files %in% files_scz]\n# Read data\ndata &lt;-\n  map(files_no_scz, ~ read.delim(\n    .x,\n    skip = 3,\n    header = TRUE,\n    sep = \"\"\n  ))\ndata_scz &lt;-\n  map(files_scz, ~ read.delim(\n    .x,\n    skip = 4,\n    header = TRUE,\n    sep = \"\"\n  ))\n\n\n# Function to add the group and adjust the pvals\nprocess_magma_data &lt;-\n  function(df,\n           filename) {\n    df &lt;- df |&gt; \n      # Add groups and adjusted pvals to data\n      dplyr::mutate(group = filename, \n                    p_adj = p.adjust(P, method = \"bonferroni\"))\n    return(df)\n  }\nscz &lt;- map2(data_scz, files_scz, ~ process_magma_data(.x, .y)) |&gt;\n  list_rbind() |&gt;\n  as_tibble()\nnon_scz &lt;- map2(data, files_no_scz, process_magma_data) |&gt;\n  list_rbind() |&gt;\n  as_tibble()\n# combine data\ndf &lt;- rbind(scz, non_scz)\n\n# Use str_extract() to extract get the percent of genes used\ndf$percent_genes &lt;- str_extract(df$group, \"\\\\d+_percent\")\n# clean up the group strings\ndf$group &lt;- basename(df$group) |&gt;\n  str_replace(\"magma_input_genes_\", \"\") |&gt;\n  str_replace(\"ppi_sig_modules_\", \"\") |&gt;\n  str_replace(\"\\\\d+_percent_\", \"\") |&gt;\n  str_replace(\"_gene_analysis\", \"\") |&gt;\n  str_replace(\".gsa.out\", \"\")\n\n# Get label of PPI\ndf$ppi &lt;- ifelse(grepl(\"_module\", df$VARIABLE), \"PPI\", \"Not-PPI\")\ndf_ppi &lt;- df[df$ppi == \"PPI\",]\ndf &lt;- df[df$ppi == \"Not-PPI\",]\n\ngt::gt(head(df))\n\n\n\n\n\n\n  \n    \n      VARIABLE\n      TYPE\n      NGENES\n      BETA\n      BETA_STD\n      SE\n      P\n      group\n      p_adj\n      percent_genes\n      ppi\n    \n  \n  \n    BR\nSET\n453\n-0.018014\n-0.0027569\n0.050638\n0.63898\nscz.25k\n1\n1_percent\nNot-PPI\n    LG\nSET\n441\n-0.036286\n-0.0054812\n0.050910\n0.76199\nscz.25k\n1\n1_percent\nNot-PPI\n    LV\nSET\n445\n-0.018273\n-0.0027725\n0.050262\n0.64191\nscz.25k\n1\n1_percent\nNot-PPI\n    BR\nSET\n453\n-0.024477\n-0.0037405\n0.049337\n0.69009\nscz.50k\n1\n1_percent\nNot-PPI\n    LG\nSET\n441\n-0.024758\n-0.0037342\n0.050784\n0.68705\nscz.50k\n1\n1_percent\nNot-PPI\n    LV\nSET\n445\n-0.018610\n-0.0028194\n0.050612\n0.64345\nscz.50k\n1\n1_percent\nNot-PPI"
  },
  {
    "objectID": "02-magma.html#load-libraries",
    "href": "02-magma.html#load-libraries",
    "title": "Disease risk gene enrichment anlaysis via MAGMA",
    "section": "",
    "text": "Code\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggthemes)\nlibrary(tximport)\nlibrary(pheatmap)\nlibrary(tibble)\nlibrary(purrr)\nlibrary(readr)\nlibrary(here)\nlibrary(stringr)\nlibrary(gt)\nlibrary(ComplexHeatmap)"
  },
  {
    "objectID": "02-magma.html#load-the-magma-outputs",
    "href": "02-magma.html#load-the-magma-outputs",
    "title": "Disease risk gene enrichment anlaysis via MAGMA",
    "section": "",
    "text": "So in our case we’re interested in the .gsa.out files MAGMA has produced as these contain the stats for if our gene lists were significantly enriched for our risk genes. A fun complication is the our schizophrenia and white matter hyperintensities outputs have a 4 line header to skip when reading the file in, whereas all the others have a 3 line header.\nAlso note that I process the ppi module lists here as well. What do you think the advantage of adding that data here for analysis is? Why not just copy all this code to a new file or just add it to the rest of the PPI code and just change the input data?\nAdd your thoughts below:\n\n\nCode\n# List files\nfiles &lt;- list.files(here::here(\"data/magma/results\"), \n                    pattern = \"*.gsa.out\", full.names = TRUE)\nfiles_ppi &lt;- list.files(here::here(\"data/ppi/magma_results\"), \n                    pattern = \"*.gsa.out\", full.names = TRUE)\nfiles &lt;- c(files, files_ppi)\n# separate scz files\nfiles_scz &lt;- files[grepl(\"_scz|_wmh_\", files)]\nfiles_no_scz &lt;- files[!files %in% files_scz]\n# Read data\ndata &lt;-\n  map(files_no_scz, ~ read.delim(\n    .x,\n    skip = 3,\n    header = TRUE,\n    sep = \"\"\n  ))\ndata_scz &lt;-\n  map(files_scz, ~ read.delim(\n    .x,\n    skip = 4,\n    header = TRUE,\n    sep = \"\"\n  ))\n\n\n# Function to add the group and adjust the pvals\nprocess_magma_data &lt;-\n  function(df,\n           filename) {\n    df &lt;- df |&gt; \n      # Add groups and adjusted pvals to data\n      dplyr::mutate(group = filename, \n                    p_adj = p.adjust(P, method = \"bonferroni\"))\n    return(df)\n  }\nscz &lt;- map2(data_scz, files_scz, ~ process_magma_data(.x, .y)) |&gt;\n  list_rbind() |&gt;\n  as_tibble()\nnon_scz &lt;- map2(data, files_no_scz, process_magma_data) |&gt;\n  list_rbind() |&gt;\n  as_tibble()\n# combine data\ndf &lt;- rbind(scz, non_scz)\n\n# Use str_extract() to extract get the percent of genes used\ndf$percent_genes &lt;- str_extract(df$group, \"\\\\d+_percent\")\n# clean up the group strings\ndf$group &lt;- basename(df$group) |&gt;\n  str_replace(\"magma_input_genes_\", \"\") |&gt;\n  str_replace(\"ppi_sig_modules_\", \"\") |&gt;\n  str_replace(\"\\\\d+_percent_\", \"\") |&gt;\n  str_replace(\"_gene_analysis\", \"\") |&gt;\n  str_replace(\".gsa.out\", \"\")\n\n# Get label of PPI\ndf$ppi &lt;- ifelse(grepl(\"_module\", df$VARIABLE), \"PPI\", \"Not-PPI\")\ndf_ppi &lt;- df[df$ppi == \"PPI\",]\ndf &lt;- df[df$ppi == \"Not-PPI\",]\n\ngt::gt(head(df))\n\n\n\n\n\n\n  \n    \n      VARIABLE\n      TYPE\n      NGENES\n      BETA\n      BETA_STD\n      SE\n      P\n      group\n      p_adj\n      percent_genes\n      ppi\n    \n  \n  \n    BR\nSET\n453\n-0.018014\n-0.0027569\n0.050638\n0.63898\nscz.25k\n1\n1_percent\nNot-PPI\n    LG\nSET\n441\n-0.036286\n-0.0054812\n0.050910\n0.76199\nscz.25k\n1\n1_percent\nNot-PPI\n    LV\nSET\n445\n-0.018273\n-0.0027725\n0.050262\n0.64191\nscz.25k\n1\n1_percent\nNot-PPI\n    BR\nSET\n453\n-0.024477\n-0.0037405\n0.049337\n0.69009\nscz.50k\n1\n1_percent\nNot-PPI\n    LG\nSET\n441\n-0.024758\n-0.0037342\n0.050784\n0.68705\nscz.50k\n1\n1_percent\nNot-PPI\n    LV\nSET\n445\n-0.018610\n-0.0028194\n0.050612\n0.64345\nscz.50k\n1\n1_percent\nNot-PPI"
  },
  {
    "objectID": "02-magma.html#heatmaps",
    "href": "02-magma.html#heatmaps",
    "title": "Disease risk gene enrichment anlaysis via MAGMA",
    "section": "Heatmaps",
    "text": "Heatmaps\nLet’s try making a heatmap to visualise the results as well\n\n\nCode\n# Transform the p-values to -log10(p-value) to enhance the visualization of small p-values\ndf$log_p &lt;- -log10(df$p_adj)\n\n# Nest data on broad groups\ndf_nest &lt;- df |&gt; \n  dplyr::arrange(group, ppi) |&gt;\n  dplyr::group_by(percent_genes) |&gt;\n  tidyr::nest()\n\nget_heatmap_data &lt;- function(df) {\n  # Prepare the data for the heatmap\n  heatmap_data &lt;- df |&gt;\n    dplyr::select(VARIABLE, log_p, group) |&gt;\n    tidyr::pivot_wider(names_from = VARIABLE, values_from = log_p) |&gt;\n    as.data.frame()\n  \n  rownames(heatmap_data) &lt;- heatmap_data$group\n  # Remove the first column if it contains row names (cell types)\n  heatmap_data &lt;- heatmap_data[, -1]\n  heatmap &lt;- t(heatmap_data)\n  # Replace any NAs with 0\n  #heatmap[is.na(heatmap)] &lt;- 0\n  return(heatmap)\n}\nheatmap_data &lt;- map(df_nest$data, get_heatmap_data) |&gt;\n  set_names(paste0(\"group_\", df_nest$percent_genes))\n\n\nThis is a little elaborate, but the function overlays some standard significant thresholds over the heatmap.\n\n\nCode\nmake_heatmap &lt;- function(heatmap_data, plot_title) {\n  # Define significance thresholds\n  sig_threshold1 &lt;- -log10(0.05) # Corresponds to p &lt; 0.05\n  sig_threshold2 &lt;- -log10(0.01) # Corresponds to p &lt; 0.01\n  sig_threshold3 &lt;- -log10(0.001) # Corresponds to p &lt; 0.001\n  \n  # Create an annotation matrix with the same dimensions as 'heatmap'\n  annotation_matrix &lt;-\n    matrix(\n      \"\",\n      nrow = nrow(heatmap_data),\n      ncol = ncol(heatmap_data)\n    )\n  \n  # Populate the annotation matrix with '*', '**', or '***' based on significance levels\n  annotation_matrix[heatmap_data &gt; sig_threshold3] &lt;-\n    \"***\"\n  annotation_matrix[heatmap_data &gt; sig_threshold2 &\n                      heatmap_data &lt;= sig_threshold3] &lt;- \"**\"\n  annotation_matrix[heatmap_data &gt; sig_threshold1 &\n                      heatmap_data &lt;= sig_threshold2] &lt;- \"*\"\n  \n  # Define a color palette for the heatmap\n  color_palette &lt;- colorRampPalette(c(\"blue\", \"white\", \"red\"))(100)\n  \n  # Create the heatmap with customizations\n  plot &lt;- Heatmap(\n    heatmap_data,\n    name = \"-log10(p-value)\",\n    col = color_palette,\n    # Use the defined color palette\n    cell_fun = function(j, i, x, y, width, height, fill) {\n      if (annotation_matrix[i, j] != \"\") {\n        grid.text(annotation_matrix[i, j], x, y, gp = gpar(col = \"black\", fontsize = 10))\n      }\n    },\n    # Adjust the clustering method if necessary\n    cluster_rows = FALSE,\n    cluster_columns = FALSE,\n    # Show row and column names\n    show_row_names = TRUE,\n    show_column_names = TRUE,\n    # Adjust the size of row and column names\n    row_names_gp = gpar(fontsize = 10),\n    #column_names_rot = 45,\n    column_names_gp = gpar(fontsize = 8),\n    column_names_max_height = max_text_height(colnames(heatmap_data),\n                                              gp = gpar(fontsize = 500)),\n    column_title = plot_title\n  )\n  \n  return(plot)\n  \n}\n\n# Get heatmaps\nheatmaps &lt;-\n  map2(heatmap_data,\n         names(heatmap_data) |&gt;\n         str_replace(\"group_\", \"top_\"),\n       make_heatmap)\n# Print them together\nhmap_list &lt;- heatmaps$group_1_percent + heatmaps$group_5_percent + heatmaps$group_10_percent\n\n\nWarning: Heatmap/annotation names are duplicated: -log10(p-value)\n\n\nWarning: Heatmap/annotation names are duplicated: -log10(p-value),\n-log10(p-value)\n\n\n\n\nCode\nhmap_list\n\n\n\n\n\nFigure 1: Heatmap of log10 adjusted pvals from MAGMA ran against several GWAS backgrounds with top genes from each condition\n\n\n\n\nNotice anything interesting about the results in Figure 1? Feel free to write up your thoughts below!"
  },
  {
    "objectID": "02-magma.html#ppi-modules",
    "href": "02-magma.html#ppi-modules",
    "title": "Disease risk gene enrichment anlaysis via MAGMA",
    "section": "PPI modules",
    "text": "PPI modules\nSince we don’t have different percentages of genes to think about, let’s look at both the nominal and adjusted pvals.\n\n\nCode\ndf_ppi$log_p &lt;- -log10(df_ppi$p_adj)\nheatmap_data &lt;- get_heatmap_data(df_ppi)\n\n\n\n\nCode\nppi_heatmap &lt;- make_heatmap(heatmap_data, \"PPI modules - p_adj\")\n\n\n\n\nCode\ndf_ppi$log_p &lt;- -log10(df_ppi$P)\nheatmap_data &lt;- get_heatmap_data(df_ppi)\nppi_heatmap_noadj &lt;- make_heatmap(heatmap_data, \"PPI modules - p_nominal\")\njoined_plot &lt;- ppi_heatmap + ppi_heatmap_noadj\n\n\n\n\nCode\njoined_plot\n\n\n\n\n\nFigure 2: Heatmap of log10 adjusted/nominal pvals from MAGMA ran against several GWAS backgrounds with protein-protein interaction network modules"
  },
  {
    "objectID": "03-protein_protein_interactions.html",
    "href": "03-protein_protein_interactions.html",
    "title": "Investigating protein-protein interaction networks",
    "section": "",
    "text": "Code\nhere::i_am(\"03-protein_protein_interactions.qmd\")\n\n\nhere() starts at /home/training/Extracting_info_from_omics/EBI-workshop---Extracting-information-from-omics-data\nSo the idea here is to look if we see more genes encoding proteins that interact with each other then we would expect to observe by chance. If we do, then this could imply some directed biological change in a pathway in that condition/celltype.\nThe common way this is used is again with single cell seq data on celltype-specific differentially expressed genes by condition. So as an example, if we saw a bunch of interacting proteins in microglia from a AD differential expression, we might want to look more closely at what pathways those particular genes are associated with to try and pin-point some more specific biology underpinning the disease that could be investigated further."
  },
  {
    "objectID": "03-protein_protein_interactions.html#background-list",
    "href": "03-protein_protein_interactions.html#background-list",
    "title": "Investigating protein-protein interaction networks",
    "section": "Background list",
    "text": "Background list\nWe want a background list of genes to be able to test if our contrasts have more interacting proteins than we would expect by chance. Here we’ll use the full list of genes we have in these samples.\nCan you add an assertthat test to make sure we have no duplicated genes in our background?\n\n\nCode\nbackground_population &lt;- readr::read_lines(here::here(\"data/ppi/background_genes.txt\"))\nassertthat::assert_that(sum(duplicated(background_population)) == 0)\n\n\n[1] TRUE\n\n\nOur protein-protein-interaction network is human so let’s convert our ensembl IDs from mouse to human.\nOnce again biomart isn’t playing ball so let’s use the same manual download again.\n\n\nCode\nensembl &lt;- useEnsembl(biomart=\"ensembl\", dataset=\"hsapiens_gene_ensembl\")\nmouse &lt;- useEnsembl(biomart=\"ensembl\", dataset=\"mmusculus_gene_ensembl\")\n\nhuman_genes &lt;- getLDS(attributes = c(\"ensembl_gene_id\"),\n                      filters = \"ensembl_gene_id\",\n                      values = res_sig$gene,\n                      mart = mouse,\n                      attributesL = c(\"hsapiens_homolog_ensembl_gene\"),\n                      martL = ensembl)\n\n\n\n\nCode\nmouse_ids &lt;- readr::read_tsv(here::here(\"data/mouse_mart_export.txt\")) |&gt;\n  janitor::clean_names()\n\n\nRows: 63042 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (2): Gene stable ID, Human gene stable ID\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nCode\ndf &lt;- res_sig |&gt;\n  dplyr::left_join(mouse_ids, by = join_by(gene == gene_stable_id),\n                   relationship = \"many-to-many\") |&gt;\n  # Keep only one instance of duplicates\n  dplyr::filter(\n    !duplicated(human_gene_stable_id) |\n      duplicated(human_gene_stable_id, fromLast = TRUE)\n  )\n\n# Convert background\nhuman_background &lt;-\n  mouse_ids[mouse_ids$gene_stable_id %in% background_population,]$human_gene_stable_id |&gt;\n  unique()\nhuman_background &lt;- human_background[!is.na(human_background)]\n\n\nWe also want gene length data since larger genes would theoretically have more domains and therefore more potential interactions, so by getting the gene length we can try to account for this in our analysis.\nThis next chunk can take a little while to run so I’ll leave the eval as false and feel free to just skip running it and use the saved data.\n\n\nCode\n# Note that it can take a while to download the gene lists, so I've set eval \n# to false for this chunk.\nensembl = useEnsembl(biomart=\"ensembl\")\nhuman &lt;- useDataset(\"hsapiens_gene_ensembl\", mart = ensembl)\n\n# CDS length # \ncds &lt;- getBM(attributes = c(\"ensembl_gene_id\", \"cds_length\"),\n            mart = mouse)\ncolnames(cds) &lt;- c(\"ensembl_gene_id\", \"cds_length\")\ncds &lt;- cds[-which(is.na(cds$cds_length)== TRUE), ]\ncds &lt;- cds[order(cds$ensembl_gene_id), ]\ncds_max &lt;- aggregate.data.frame(cds, by = list(cds$ensembl_gene_id), FUN = max)\ncds_max &lt;- cds_max[, c(\"ensembl_gene_id\", \"cds_length\")]\ncds_max &lt;- cds_max[cds_max$ensembl_gene_id %in% human_background, ]\nwrite.table(cds_max, here::here(\"data/ppi/EnsemblGeneID_MaxCDSlength.txt\"), \n            sep = \"\\t\", quote = FALSE, row.names = FALSE, col.names = FALSE)"
  },
  {
    "objectID": "03-protein_protein_interactions.html#design",
    "href": "03-protein_protein_interactions.html#design",
    "title": "Investigating protein-protein interaction networks",
    "section": "Design",
    "text": "Design\nSo let’s try this for each of our contrasts separately.\nThere’s also a choice to be made here. We can either use the whole protein-protein interaction network, which is much bigger as it includes lots of inferred interactions, or we can subset our network to just those with known physical interactions. You’re more likely to find something if you use the whole network, but it’s also more possible that the interactions might not be real.\nHow would you approach this trade-off?\n\n\nCode\n# Get dfs separated by contrast\ngene_list &lt;- df |&gt;\n  dplyr::group_by(condition) |&gt;\n  tidyr::nest()\n\n# # # SELECT YOUR NETWORK FILE # # # \n# Read the file into a dataframe\n# The physical interactions only\nppi_data &lt;- read.table(here::here(\"data/ppi/MergedPPI_2024Feb_PIO_STRING.txt\"), \n                       header = FALSE, as.is = TRUE)\n# The full network including inferred interactions\n# ppi_data &lt;- read.table(here::here(\"data/ppi/MergedPPI_2024Feb.txt\"), \n#                        header = FALSE, as.is = TRUE)\n\n# Create an igraph object from the dataframe\nmy_network &lt;- graph_from_data_frame(ppi_data, directed = FALSE)\nrm(ppi_data)\n# Check the graph\nsummary(my_network)\n\n\nIGRAPH bb7e3ad UN-- 22651 1496213 -- \n+ attr: name (v/c)\n\n\nCode\nedge_attr(my_network, \"weight\", index = E(my_network)) &lt;- 1\n\n\n\n\nCode\n# # #  INPUT gene attributes  # # # \n# Gene length / max CDS length\ngene_length &lt;- read.table(here::here(\"data/ppi/EnsemblGeneID_MaxCDSlength.txt\"), \n                         sep = \"\\t\", header = FALSE, \n                         stringsAsFactors = FALSE)\ncolnames(gene_length) &lt;- c(\"ensembl_gene_id\", \"gene_length\")\n\n\n# # # SETUP NUMBER OF RANDOM SAMPLES to create your NULL # # #\nm &lt;- 10000\n# I'd normally default to 10K, but this can take a sec to run, so for the \n# workshop let's use 1K\nm &lt;- 1000\n\n# # # Set to \"D\" to take into account degree, \n# # # \"GL\" to taken into account Gene length, \n# # # or \"B\" to take into account both degree and Gene length\ngene_attribute &lt;- \"B\"\n\n# # # CHANGE the name of your OUTPUT FILE that will contain your test against NULL # # #\noutput_file &lt;-\n  here::here(\n    \"data/ppi\",\n    \"PPI_Test1\"\n  )\n\n# Output Louvain clusters\noutput_file2 &lt;-\n  here::here(\n    \"data/ppi\",\n    \"PPI_Test1-Louvain_\")\n\n\nHere we set the minimum number of genes for clustering. Change this number to something other than 5 (I’d suggest a higher number)!\n\n\nCode\n# Min number of genes for a cluster\nmin_cluster_size &lt;- 5\n\n\n\n\nCode\n# Add test type to the output file name\nif(gene_attribute == \"D\") {\n  output_file &lt;- paste(output_file, \"MatchDegree\", sep = \"_\")} else {\n  if(gene_attribute == \"GL\") {\n  output_file &lt;- paste(output_file, \"MatchGenelength\", sep = \"_\")} else {\n    if(gene_attribute == \"B\"){\n  output_file &lt;- paste(output_file, \"MatchDegreeAndGenelength\", sep = \"_\")   \n    }\n  }\n}\n    \n# Pull out the ensembl list for each contrast\nmy_gene_list &lt;- map(gene_list$data, ~ dplyr::pull(.x, human_gene_stable_id)) |&gt;\n  purrr::set_names(gene_list$condition)"
  },
  {
    "objectID": "03-protein_protein_interactions.html#gene-lists-for-analysis",
    "href": "03-protein_protein_interactions.html#gene-lists-for-analysis",
    "title": "Investigating protein-protein interaction networks",
    "section": "Gene lists for analysis",
    "text": "Gene lists for analysis\n\n\nCode\nprocess_network &lt;- function(background) {\n  # Reduce my network to background population of genes tested #\n  Gbg &lt;- vertex_attr(my_network)$name\n  BG &lt;- intersect(background, intersect(Gbg, gene_length$ensembl_gene_id))\n  my_network &lt;- induced_subgraph(graph = my_network, vids = BG)\n  \n  # Create tables with the GENE attributes provided for the background population found in my network #\n  # Calculate and order genes according to their degree in my network #\n  D &lt;- igraph::degree(my_network, mode = \"all\")\n  D &lt;- data.frame(ensembl_gene_id = names(D), degree = D)\n  D &lt;- D[order(D$degree, decreasing = TRUE),]\n  rownames(D) &lt;- 1:nrow(D)\n  \n  # Order genes by Gene length #\n  gene_length &lt;- gene_length[gene_length$ensembl_gene_id %in% BG, ]\n  gene_length &lt;- gene_length[order(gene_length$gene_length, decreasing = TRUE), ]\n  rownames(gene_length) &lt;- 1:nrow(gene_length)\n  \n  # Combined score Degree and Gene length\n  B &lt;- merge(D, gene_length, by = \"ensembl_gene_id\")\n  B &lt;- data.frame(B, \n                  scaled_degree = rescale01(B$degree), \n                  scaled_gene_length = rescale01(B$gene_length), \n                  score = rescale01(B$degree) + rescale01(B$gene_length))\n  B &lt;- B[order(B$score,  decreasing = TRUE), ]\n  rownames(B) &lt;- 1:nrow(gene_length)\n  \n  # Report numbers\n  print(paste0(\"Background population: \", length(background), \" genes\"))\n  print(paste0(\"Genes in the network: \", length(Gbg), \" genes\"))\n  print(\n    paste0(\n      \"Background population contained in the network and used for analysis: \",\n      length(BG),\n      \" genes\"\n    )\n  )\n  \n  x &lt;- map(my_gene_list, ~ length(intersect(.x, BG)))\n  x &lt;- map2(x, names(my_gene_list), ~ print(paste0(\"Genes of interest contained in the network and used for analysis: \", .x, \" for condition\", .y)))\n  \n  return(list(\"BG\" = BG, \"network\" = my_network, \"D\" = D, \"B\" = B))\n}\n\nres &lt;- process_network(human_background)\n\n\n[1] \"Background population: 18649 genes\"\n[1] \"Genes in the network: 22651 genes\"\n[1] \"Background population contained in the network and used for analysis: 17040 genes\"\n[1] \"Genes of interest contained in the network and used for analysis: 4110 for conditionBR\"\n[1] \"Genes of interest contained in the network and used for analysis: 3505 for conditionLG\"\n[1] \"Genes of interest contained in the network and used for analysis: 79 for conditionLV\"\n\n\nCheck total number of genes of interest\n\n\nCode\nx &lt;- map2(gene_list$condition, my_gene_list, ~ print(paste0(\"Genes of interest: \", length(.y), \" for condition \", .x)))\n\n\n[1] \"Genes of interest: 5249 for condition BR\"\n[1] \"Genes of interest: 4535 for condition LG\"\n[1] \"Genes of interest: 1107 for condition LV\""
  },
  {
    "objectID": "03-protein_protein_interactions.html#subnetwork-plot",
    "href": "03-protein_protein_interactions.html#subnetwork-plot",
    "title": "Investigating protein-protein interaction networks",
    "section": "Subnetwork plot",
    "text": "Subnetwork plot\n\nInteraction network of the genes of interest.\n\n\n\nCode\nrm(background_population)\n\n# Function to intersect each cell type gene list with a single background list\nintersect_with_background &lt;- function(background_genes, cell_type_gene_list) {\n  map(cell_type_gene_list, ~ intersect(.x, y = background_genes))\n}\nmy_gene_list &lt;- intersect_with_background(res$BG, my_gene_list)\n\n\n\n\nCode\n# Define subnetwork\nmy_subgraph &lt;-\n  map(my_gene_list, ~ induced_subgraph(graph = res$network, vids = .x))\n\n\nWe can plot our networks at this stage, though the code can take a little while to run!\n\n\nCode\n# Plot subnetwork\nmap2(my_subgraph, names(my_subgraph),\n  ~ plot(\n    .x,\n    vertex.size = 3,\n    vertex.color = \"darkslateblue\",\n    vertex.frame.color = \"darkslateblue\",\n    edge.color = \"grey\",\n    rescale = TRUE,\n    vertex.label = NA,\n    main = paste0(\"Condition: \", .y)\n  )\n)\n\n\n\n\n\n\n\n\n\n\n\n$BR\nNULL\n\n$LG\nNULL\n\n$LV\nNULL"
  },
  {
    "objectID": "03-protein_protein_interactions.html#test-for-number-of-interactions",
    "href": "03-protein_protein_interactions.html#test-for-number-of-interactions",
    "title": "Investigating protein-protein interaction networks",
    "section": "Test for number of interactions",
    "text": "Test for number of interactions\n\n\nCode\nperform_permutation &lt;- function(gene_list, gene_list_name, my_network, BG, gene_attribute, m, num_cores = detectCores() - 1) {\n  \n  print(paste0(\"Processing \", gene_list_name))\n  \n  # Gene population of interest\n  gene_list_A &lt;- intersect(gene_list, BG)\n\n  # Sum of the edges within gene list A\n  mynet_gl &lt;- induced_subgraph(my_network, vids = gene_list_A)\n  w_mynet_gl &lt;- edge.attributes(mynet_gl)$weight\n  o &lt;- sum(w_mynet_gl)\n  \n  # Sum of the edges from within a random gene list size A\n  # Use mclapply to parallelize the replicate function\n  e &lt;- mclapply(1:m, function(i) {\n    rnd_smpl &lt;- similar_gene_list(gene_list = gene_list_A, attr_matrix = gene_attribute, rango = 100)\n    rnd_mynet_gl &lt;- induced_subgraph(my_network, vids = rnd_smpl)\n    rnd_w_mynet_gl &lt;- edge.attributes(rnd_mynet_gl)$weight\n    sum(rnd_w_mynet_gl)\n  }, mc.cores = num_cores)\n  # Convert the list to a vector\n  e &lt;- unlist(e)\n\n  p &lt;- length(which(e &gt;= o)) / m\n\n  # Write to dataframe\n  df &lt;- data.frame(\"gene_list\" = gene_list_name, \"o\" = o, \"e\" = mean(e), \"sem\" = sd(e), \"p\" = p)\n  return(df)\n  \n  print(paste0(\"Finished processing \", gene_list_name))\n}\n\nresults &lt;-\n  map2(\n    my_gene_list,\n    names(my_gene_list),\n    ~ perform_permutation(\n      .x,\n      .y,\n      my_network = res$network,\n      BG = res$BG,\n      gene_attribute = res[[gene_attribute]],\n      m = m\n    )\n  ) |&gt;\n  list_rbind()\n\n\n[1] \"Processing BR\"\n[1] \"Processing LG\"\n[1] \"Processing LV\"\n\n\n\nResults\n\n\nCode\nreadr::write_tsv(results, paste0(output_file, \".tsv\"))\n# Add adjusted pvalues\nresults$pval &lt;- ifelse(results$p == 0, 1e-8, results$p)\nresults$padj &lt;- p.adjust(results$pval, method = \"bonferroni\")\n# Table with results of test\nDT::datatable(\n  results,\n  caption = \"Test if the number of interactions is higher than expected by chance\",\n  rownames = FALSE\n) %&gt;% formatRound(columns = c(\"e\", \"sem\", \"padj\"), digits = c(2))\n\n\n\n\n\n\n\n\no observed number of interactions.\ne expected number of interactions based on {r} m randomizations.\nsem standard error of the mean based on {r} m randomizations.\np estimated p value based on {r} m randomizations.\nNote If a weighted network is provided then it is a test for the sum of the edge’s weights."
  },
  {
    "objectID": "03-protein_protein_interactions.html#louvain-clustering",
    "href": "03-protein_protein_interactions.html#louvain-clustering",
    "title": "Investigating protein-protein interaction networks",
    "section": "Louvain clustering",
    "text": "Louvain clustering\n\n\nCode\nperform_louvain_clustering &lt;- function(subgraph, min_cluster_size, label) {\n  # Louvain clustering\n  cl &lt;- cluster_louvain(subgraph)\n  \n  # Determine clusters smaller than the minimum size\n  cluster_sizes &lt;- table(cl$membership)\n  not_assigned &lt;- names(cluster_sizes[cluster_sizes &lt; min_cluster_size])\n  num_clusters &lt;- names(cluster_sizes[cluster_sizes &gt;= min_cluster_size])\n  \n  # Colour assignment\n  cl_cols &lt;- rainbow(n = length(num_clusters))\n  \n  # Vectorized color assignment\n  cl_colors &lt;- rep(\"grey\", cl$vcount)\n  membership_to_color &lt;- setNames(cl_cols, num_clusters)\n  cl_colors[cl$membership %in% num_clusters] &lt;- membership_to_color[as.character(cl$membership[cl$membership %in% num_clusters])]\n  \n  # Dataframe with clustering and colours\n  module_assignment &lt;- data.frame(gene = cl$names, \n                                  module = cl$membership, \n                                  module_color = cl_colors,\n                                  label = label)\n  \n  return(module_assignment)\n}\n\nmodule_assignment &lt;-\n  map2(\n    my_subgraph,\n    names(my_subgraph),\n    ~ perform_louvain_clustering(.x, min_cluster_size, .y)\n  )\n\n\nHave a look at the network plots below. Do you notice anything about them?\n\n\nCode\n# Plot clustering\nmap2(my_subgraph, module_assignment, ~ plot(.x, \n     vertex.size = 3, \n     vertex.color = as.character(.y$module_color), \n     vertex.frame.color = .y$module_color, \n     edge.color = \"grey\",  \n     rescale = TRUE, \n     vertex.label = NA,\n     main = paste0(\"Condition: \", .y$label[1])))\n\n\n\n\n\n\n\n\n\n\n\n$BR\nNULL\n\n$LG\nNULL\n\n$LV\nNULL\n\n\nCode\noutput_file2 &lt;- paste(output_file2, paste(\"MinSize\"), min_cluster_size, sep = \"\")\n\n# Save clustering as file\nwrite.table(list_rbind(module_assignment), \n            file = output_file2, \n            col.names = FALSE, \n            row.names = FALSE, \n            quote = TRUE)"
  },
  {
    "objectID": "03-protein_protein_interactions.html#module-assignment",
    "href": "03-protein_protein_interactions.html#module-assignment",
    "title": "Investigating protein-protein interaction networks",
    "section": "Module assignment",
    "text": "Module assignment\nHaving assigned the genes to modules the next thing to do is choose which conditions to take forward to assign functions via GO pathways to.\n\n\nCode\n# Get modules assignment\nmodules &lt;- list_rbind(module_assignment)\n# Get significant conditions\nsig_conditions &lt;- results |&gt;\n  dplyr::filter(p &lt; 0.05)\n\n\nFor cases where the number of genes is small, there isn’t a need to use the clusters, though there isn’t a rule of thumb for a cutoff for this. In this case there aren’t any with a very low number, but let’s have some code for skipping clustering for conditions that have less than 30 genes.\n\n\nCode\n# Get number of genes per conditions\ngene_num &lt;- map_dbl(my_gene_list, length)\n# Check the gene numbers per conditions of interest\ngene_num &lt;- gene_num[names(gene_num) %in% sig_conditions$gene_list]\ngene_num\n\n\n  BR   LG   LV \n4110 3505   79 \n\n\nCode\n# Get the conditions with fewer than 30 genes\nconditions_with_few_genes &lt;- names(gene_num)[gene_num &lt; 30]\n\n\n\n\nCode\nmodules_sig &lt;- modules |&gt;\n  # Filiter to sig conditions\n  dplyr::filter(label %in% sig_conditions$gene_list) |&gt;\n  # Update modules for conditions with low number of genes to all be the same\n  dplyr::mutate(module_updated = case_when(\n    label %in% conditions_with_few_genes ~ 1,\n    .default = module\n  ))\n\n\n\n\nCode\ngene_list &lt;- modules_sig %&gt;% \n  group_by(label, module) %&gt;% \n  tidyr::nest()\n\n\n\nGO enrichment\nHere we want entrez IDs, and notice the use of tryCatch to allow R to continue through errors caused then the conversion fails.\nIt might be nice to add a little counter for the number of conversions that fail as well, give that a go if you fancy a challenge! Perhaps you could also return the gene IDs that failed to convert as well?\nAlso note the handy little trick of using file.exists to only run certain code that might take a while to run if the results of that computation haven’t already been generated.\n\n\nCode\nconvert_to_entrez &lt;- function(gene_list) {\n  tryCatch({\n    bitr(gene_list, fromType = \"ENSEMBL\", toType = \"ENTREZID\", OrgDb = org.Hs.eg.db)\n  }, error = function(e) {\n    message(\"An error occurred: \", e$message)\n    return(NULL) # Return NULL if the conversion fails\n  })\n}\n# Convert Ensembl IDs to Entrez IDs\ngene_list_entrez &lt;- map(gene_list$data, ~ {\n  tryCatch({\n    bitr(.x$gene, fromType = \"ENSEMBL\", toType = \"ENTREZID\", OrgDb = org.Hs.eg.db)\n  }, error = function(e) {\n    message(\"An error occurred: \", e$message)\n    return(NULL) # Return NULL if the conversion fails\n  })\n})\n\n# Filter out any NULL entries if there were conversion errors\ngene_list_entrez &lt;- map(gene_list_entrez, ~ .x |&gt;\n                          # remove any missing data\n                          dplyr::filter(!is.na(ENTREZID)) |&gt;\n                          dplyr::pull(ENTREZID))\n\nentrez_background &lt;- convert_to_entrez(gene_ensembl_ids$ensembl)\n\n# Save file - it takes a while to compute\nfile &lt;-\n  here::here(\n    \"data/ppi/module_go_terms.rds\"\n  )\n\nif (!file.exists(file)) {\n  plan(multisession, workers = detectCores() - 1)\n  result_list &lt;- future_map(\n    gene_list_entrez,\n    ~ enrichGO(\n      gene          = .x,\n      OrgDb         = org.Hs.eg.db,\n      keyType       = \"ENTREZID\",\n      # \"BP\" for biological process, \"MF\" for molecular function, \"CC\" for cellular component\n      ont           = \"ALL\",\n      universe      = entrez_background,\n      pAdjustMethod = \"BH\",\n      qvalueCutoff  = 0.05,\n      readable      = TRUE\n    ), .options = furrr_options(seed = 123)\n  ) |&gt;\n    set_names(paste0(gene_list$label, \"_module\", gene_list$module))\n  \n  readr::write_rds(result_list, file)\n} else {\n  result_list &lt;- readr::read_rds(file)\n}\n\n\n# Remove any NULL entries\nresult_list &lt;- result_list[!sapply(result_list, is.null)]\n# Assert that there are no nulls in list\nassertthat::see_if(sum(map_lgl(result_list, is.null)) == 0)\n\n\n[1] TRUE\n\n\nCode\n# Filter the list to keep only elements where the 'result' slot has rows\nresult_list &lt;- result_list[sapply(result_list, function(x) nrow(x@result) &gt; 0)]\n\n\n\n\nSave for MAGMA\nWhilst we’ve got the entrez IDs handy we may as well save the lists to be run through MAGMA! Let’s exclude modules that only have one gene in them as well.\nHave a think about why we might do this and write your thoughts below\n\n\nCode\n# Save to MAGMA\nnames(gene_list_entrez) &lt;- paste0(gene_list$label, \"_module\", gene_list$module)\n\n# Exclude one gene modules\ngene_list_entrez &lt;- gene_list_entrez[map_dbl(gene_list$data, nrow) != 1]\nnames(gene_list_entrez)\n\n\n [1] \"BR_module1\"  \"BR_module2\"  \"BR_module3\"  \"BR_module4\"  \"BR_module5\" \n [6] \"BR_module6\"  \"BR_module7\"  \"BR_module8\"  \"BR_module9\"  \"BR_module11\"\n[11] \"BR_module18\" \"LG_module1\"  \"LG_module2\"  \"LG_module3\"  \"LG_module4\" \n[16] \"LG_module5\"  \"LG_module6\"  \"LG_module7\"  \"LG_module8\"  \"LV_module1\" \n[21] \"LV_module2\"  \"LV_module3\"  \"LV_module6\"  \"LV_module9\"  \"LV_module10\"\n[26] \"LV_module15\"\n\n\nCode\n# Create a character vector where each element is a single string\nlines_to_write &lt;- sapply(names(gene_list_entrez), function(name) {\n  paste(name, paste(gene_list_entrez[[name]], collapse = \" \"))\n}, USE.NAMES = FALSE)\n\n# Write the character vector to a file\nreadr::write_lines(lines_to_write, \n                   here::here(\"data/ppi/ppi_sig_modules.magma.txt\"))\n\n\n\n\nTreeplots\nThe enrichplot has a nice function to evaluate the similarity of GO terms as there’s a lot of redundancy and overlap in the terms. It also includes a nice treeplot function to visualise the terms based on their similarity.\n\n\nCode\n# Plotting the first module's GO enrichment result as an example\nif (length(result_list[[1]]) &gt; 0) {\n  dotplot(result_list[[1]])\n}\n\n\n\n\n\nCode\ndotplot(result_list$BR_module1, split = \"ONTOLOGY\")\n\n\n\n\n\nCode\n# Get semantic similarity of terms\nresult_list &lt;- map(result_list, pairwise_termsim)\ntreeplot(result_list$BR_module2)\n\n\n\n\n\nCode\n# Lots of the modules are just a single gene, it doesn't make sense to assign\n# a GO term to them, one should probably just apply the gene name as a label\nresult_list_subset = result_list[sapply(result_list, function(x) length(x@gene) &gt; 1)]\n\n# Define a safe version of your treeplot function that returns NULL on error\nsafe_treeplot &lt;- possibly(treeplot, otherwise = NULL)\n# Use map with the safe version of the function\ntreeplots &lt;- map(result_list_subset, safe_treeplot)\n\n# Remove any NULL entries\ntreeplots &lt;- treeplots[!sapply(treeplots, is.null)]\n# Assert that there are no nulls in list\nassertthat::see_if(sum(map_lgl(treeplots, is.null)) == 0)\n\n\n[1] TRUE\n\n\nCode\ntreeplots &lt;- map2(treeplots, names(treeplots), ~ .x + ggtitle(.y))\n\n# Make patchwork of plots per condition\n# Extract unique cell types from the plot names\nconditions &lt;- unique(sub(\"_module.*\", \"\", names(treeplots)))\n\n# Split the list of plots into a nested list by condition\nplots_by_condition &lt;- map(conditions, ~{\n  plots_for_type &lt;- treeplots[grepl(paste0(\"^\", .x, \"_module\"), names(treeplots))]\n  combined_plot &lt;- wrap_plots(plots_for_type, ncol = 1) # Adjust 'ncol' as needed\n  combined_plot\n})\n\n# Name the list of combined plots by condition\nnames(plots_by_condition) &lt;- conditions\n# save the plots nice and tall\nwalk2(plots_by_condition, names(plots_by_condition), ~ ggsave(\n  filename = here::here(\"data/ppi/\", paste0(.y, \"_combined_plot.png\")),\n  plot = .x,\n  width = 14,\n  height = 38\n))\n\n\n\n\nCode\nplots_by_condition$BR\n\n\n\n\n\n\n\nCode\nplots_by_condition$LG\n\n\n\n\n\n\n\nCode\nplots_by_condition$LV\n\n\n\n\n\n\n\nModule labels\nSo there isn’t really a particularly scientific or mathematical solution to assigning module labels. So you just kind of eyeball the GO terms, hope you see a nice pattern of related terms highlighted and either pick one or create your own amalgamated term…\nHave a go at picking a few labels for some modules! Maybe have a chat with your neighbours about which to assign. As a cheeky hint, maybe go have a look at the MAGMA heatmaps of the PPI modules to decide which ones you might like to label :P\n\n\nCode\n# Make vector of module labels\nmodule_assignments &lt;-\n  c(# BR\n    \"example_label\",\n    # LV\n    \"example_label\",\n    # LG\n    \"example_label\")\n\n# Get a vector of interim labels to use\n# Comment this line out if you assign labels yourself!\nmodule_assignments &lt;- rep(\"example_label\", length(names(treeplots)))\n\nmodule_assignments &lt;- tibble(\"module\" = names(treeplots), \"label\" = module_assignments)\n\n\nNow let’s get the gene symbol for the modules with only one gene.\n\n\nCode\ngene_num &lt;- map_dbl(result_list, ~ length(.x@gene))\none_gene &lt;- names(gene_num)[gene_num == 1]\ngenes &lt;- map_chr(one_gene, ~ result_list[[.x]]@gene)\nnames(genes) &lt;- one_gene\n\nensembl &lt;- useMart(\"ensembl\", dataset = \"hsapiens_gene_ensembl\")\n# Retrieve gene symbols\ngene_info &lt;- getBM(attributes = c('entrezgene_id', 'hgnc_symbol'),\n                   filters = 'entrezgene_id',\n                   values = genes,\n                   mart = ensembl)\n\n# Print the results\nhead(gene_info)\n\n\n\n\n\n\nentrezgene_id\nhgnc_symbol\n\n\n\n\n100131897\nINSYN2B\n\n\n100528062\nARMCX5-GPRASP2\n\n\n100528062\nGPRASP2\n\n\n100653515\nCEP295NL\n\n\n10581\nIFITM2\n\n\n1066\nCES1\n\n\n\n\n\n\nCode\n# Make sure there's no NAs in the conversion\nassertthat::noNA(gene_info)\n\n\n[1] TRUE\n\n\nCode\n# Make sure genes are arranged in the same way\nmodule_order &lt;- names(genes)[match(gene_info$entrezgene_id, genes)]\ngene_symbols &lt;- gene_info$hgnc_symbol\nnames(gene_symbols) &lt;- module_order\n\n# Update labels in the dataframe\none_gene_labels &lt;- tibble(module = names(gene_symbols), label = gene_symbols)\n\n\nAnd lastly we can combine our module labels and save them.\n\n\nCode\nmodule_assignments &lt;- rbind(module_assignments, one_gene_labels)\n# Save module assignment\nreadr::write_csv(\n  module_assignments,\n  here::here(\n    \"data/ppi/\",\n    \"ppi_sig_module_labels.csv\"\n  )\n)"
  },
  {
    "objectID": "scripts/magma_run.html",
    "href": "scripts/magma_run.html",
    "title": "MAGMA Run",
    "section": "",
    "text": "Code\nhere::i_am(\"scripts/magma_run.qmd\")\n\n\nhere() starts at /home/training/Extracting_info_from_omics/EBI-workshop---Extracting-information-from-omics-data\n\n\nHere is a rough outline of the steps one performs to prep the other input files for MAGMA and then ultimately run it with your gene lists. The first 2 chunks are preparing the GWAS summary stats your want to use. These 2 processing steps can take a little while to run, so we’ve generated the files for you in advance, but the last step is nice and quick as it’s just running the regression.\n\nStep 1 - Get SNP to Gene annotations\nFirst step is to annotate SNPs to genes, and an important choice here is what window one uses around the gene when annotating the SNPs to them. A few standard choices are 35Kb upstream and 10Kb downstream (what we use here), but some also use 25Kb or 50Kb up/downstream. In practise you might want to play around with some standard window sizes and/or check the literature in your field to see what’s common.\nAs an aside, quarto can support shell script by changing the “{r}” in the block header to “{bash}” if you use knitr as the computational engine. There’s docs about this here, including the different if you’re using Jupyter as the engine instead.\n\n\nCode\n#!/bin/bash\n\nWORK_DIR=\"path/to/magma/inputs\"\ncd $WORK_DIR\n\n# SNP file from the reference\nSNP_Loc_File=${WORK_DIR}\"g1000_eur.bim\"\n# Gene location file - make sure build is correct\nGene_Loc_File=${WORK_DIR}\"NCBI37.3.gene.loc\"\nOutput_Prefix=\"NCBI37_annotated_window_35k10k\"\n\nmagma \\\n    --annotate window=35,10 \\\n    --snp-loc $SNP_Loc_File \\\n    --gene-loc $Gene_Loc_File \\\n    --out $Output_Prefix\n\nOutput_Prefix=\"NCBI37_annotated_nowindow\"\n\nmagma \\\n    --annotate window=0\\\n    --snp-loc $SNP_Loc_File \\\n    --gene-loc $Gene_Loc_File \\\n    --out $Output_Prefix\n\n\n\n\nStep 2 - process GWAS summary stats\nHere we use our gene annotations from the prior step with summary stats from our GWAS summary stats. You can find many GWAS summary statistics on the Open GWAS project, but note that not all published GWAS stats are on there, so you may have to contact the authors of your prefered study for the stats in the worst case.\nWe have a few summary stats prepared, but I’ll just show some code for Alzheimer’s disease (AD). AD is an interesting case as the APOE gene is such a dominating hit in the GWAS that it’s common to run analysis with and without APOE included. The other think to keep in mind with AD is the use of proxy cases from UK BioBank. This is where folk who self report a first-degree relative as having had “dementia” or “AD”, they are automatically assumed to have AD as well, and so treated as a case in the latest AD GWAS. This is somewhat controversial (perhaps unsurprisingly!), and so some folk also like to do these kinds of analysis with and without the proxy cases included in the summary stats. I won’t do this here in the interest of simplisity, but it’s good to keep in mind.\n\n\nCode\n#!/bin/bash\n\nWORK_DIR=\"path/to/magma/inputs\"\n\n# PLINK files from reference (.bed/.bim/.fam)\nData_File=${WORK_DIR}\"g1000_eur\"\n# Output of step 1\nAnnot_File=${WORK_DIR}\"NCBI37_annotated_window_35k10k.genes.annot\"\n\n#### With proxies and APOE - 35k10k window\n\nmkdir temp_annot_35k10k_nobb # make a temporary directory to host the intermediate files\n\nAnnot_File=${WORK_DIR}\"NCBI37_annotated_window_35k10k.genes.annot\"\nSNP_Pval_File=\"Bellenguez_2022_sumstats/GCST90027158_buildGRCh37_noATGC_forMAGMA.tsv\"\nOutput_Prefix=\"EUROPEUKBB_35k10k\"\n\n\n# run magma in parallel, 10 threads in this case\nparallel magma \\\n   --batch {} 10 \\\n   --bfile $Data_File \\\n   --gene-annot $Annot_File \\\n   --gene-model snp-wise=mean \\\n   --pval $SNP_Pval_File ncol=N \\\n   --out temp_annot_35k10k_nobb/$Output_Prefix \\\n::: {1..10}\n\n# merge all intermediate files generated under the temp_annot files\n# and send out for one single file set\n\nmagma \\\n   --merge temp_annot_35k10k_nobb/$Output_Prefix \\\n   --out temp_annot_35k10k_nobb/$Output_Prefix\n\n# extract merged files for subsequent analysis\n\ncp ./temp_annot_35k10k_nobb/$Output_Prefix.genes.* .\n\n# remove the temporary directory\n\nrm -r temp_annot_35k10k_nobb\n\n#### With proxies and APOE - no window\n\nmkdir temp_annot_nobb # make a temporary directory to host the intermediate files\n\nAnnot_File=${WORK_DIR}\"NCBI37_annotated_nowindow.genes.annot\"\nSNP_Pval_File=\"Bellenguez_2022_sumstats/GCST90027158_buildGRCh37_noATGC_forMAGMA.tsv\"\nOutput_Prefix=\"EUROPEUKBB_nowindow\"\n\n\n# run magma in parallel, 10 threads in this case\n\nparallel magma \\\n   --batch {} 10 \\\n   --bfile $Data_File \\\n   --gene-annot $Annot_File \\\n   --gene-model snp-wise=mean \\\n   --pval $SNP_Pval_File ncol=N \\\n   --out temp_annot_nobb/$Output_Prefix \\\n::: {1..10}\n\n# merge all intermediate files generated under the temp_annot files\n# and send out for one single file set\n\nmagma \\\n   --merge temp_annot_nobb/$Output_Prefix \\\n   --out temp_annot_nobb/$Output_Prefix\n\n# extract merged files for subsequent analysis\n\ncp ./temp_annot_nobb/$Output_Prefix.genes.* .\n\n# remove the temporary directory\n\nrm -r temp_annot_nobb\n\n#### With proxies and without APOE - no window\n\nmkdir temp_annot_nobb # make a temporary directory to host the intermediate files\n\nAnnot_File=${WORK_DIR}\"NCBI37_annotated_nowindow.genes.annot\"\nSNP_Pval_File=\"Bellenguez_2022_sumstats/GCST90027158_buildGRCh37_noATGC_noAPOE_forMAGMA.tsv\"\nOutput_Prefix=\"EUROPEUKBB_nowindow_noAPOE\"\n\n# run magma in parallel, 10 threads in this case\nparallel magma \\\n   --batch {} 10 \\\n   --bfile $Data_File \\\n   --gene-annot $Annot_File \\\n   --gene-model snp-wise=mean \\\n   --pval $SNP_Pval_File ncol=N \\\n   --out temp_annot_nobb/$Output_Prefix \\\n::: {1..10}\n\n# merge all intermediate files generated under the temp_annot files\n# and send out for one single file set\n\nmagma \\\n   --merge temp_annot_nobb/$Output_Prefix \\\n   --out temp_annot_nobb/$Output_Prefix\n\n# extract merged files for subsequent analysis\n\ncp ./temp_annot_nobb/$Output_Prefix.genes.* .\n\n# remove the temporary directory\n\nrm -r temp_annot_nobb\n\n#### With proxies and without APOE - 35k10k window\n\nmkdir temp_annot_nobb # make a temporary directory to host the intermediate files\n\nAnnot_File=${WORK_DIR}\"NCBI37_annotated_window_35k10k.genes.annot\"\nSNP_Pval_File=\"Bellenguez_2022_sumstats/GCST90027158_buildGRCh37_noATGC_noAPOE_forMAGMA.tsv\"\nOutput_Prefix=\"EUROPEUKBB_35k10k_noAPOE\"\n\n# run magma in parallel, 10 threads in this case\nparallel magma \\\n   --batch {} 10 \\\n   --bfile $Data_File \\\n   --gene-annot $Annot_File \\\n   --gene-model snp-wise=mean \\\n   --pval $SNP_Pval_File ncol=N \\\n   --out temp_annot_nobb/$Output_Prefix \\\n::: {1..10}\n\n# merge all intermediate files generated under the temp_annot files\n# and send out for one single file set\n\nmagma \\\n   --merge temp_annot_nobb/$Output_Prefix \\\n   --out temp_annot_nobb/$Output_Prefix\n\n# extract merged files for subsequent analysis\n\ncp ./temp_annot_nobb/$Output_Prefix.genes.* .\n\n# remove the temporary directory\n\nrm -r temp_annot_nobb\n\n\n\n\nStep 3 - Run the MAGMA regression\nHere is the last bit where we actually get our results!\n\n\nCode\n#!/bin/bash\n\nWORK_DIR=\"~/2024-03-29_ebi_workshop/data/magma\"\ncd $WORK_DIR\nexport WORK_DIR\n\n# Populate Set_Annot_Files array with files matching '*.magma.txt'\nSet_Annot_Files=(${WORK_DIR}/*.magma.txt)\n# Populate Gene_Results_Files array with files matching '*.genes.raw'\nGene_Results_Files=(${WORK_DIR}/*.genes.raw)\n\n# Function to run magma with given files and output prefix\nrun_magma() {\n    local Set_Annot_File=$1\n    local Gene_Results_File=$2\n    local annot_name=$(basename \"${Set_Annot_File}\" .magma.txt)\n    local gene_name=$(basename \"${Gene_Results_File}\" .genes.raw)\n    local Output_Prefix=\"./results/${annot_name}_${gene_name}\"\n\n    # Run magma command\n    magma \\\n        --gene-results $Gene_Results_File \\\n        --set-annot $Set_Annot_File \\\n        --out $Output_Prefix\n}\n\n# Export the function so it can be used by parallel\nexport -f run_magma\n\n# Use parallel to run the combinations\nparallel run_magma ::: \"${Set_Annot_Files[@]}\" ::: \"${Gene_Results_Files[@]}\"\n\n\nYou might have noticed I set R as the language of the prior block even though it’s bash code. I do this so we can use purl to extract this code block to a script file by itself. You can purl with bash blocks, but the code gets commented out, so I just leave it as R (just don’t forget to set eval: false for the R blocks with bash code!). This is also why I have set purl: false in the other code blocks.\n\n\nCode\nknitr::purl(\n  here::here(\"scripts/magma_run.qmd\"),\n  here::here(\"scripts/magma_run.sh\"),\n  documentation = 0\n)"
  }
]